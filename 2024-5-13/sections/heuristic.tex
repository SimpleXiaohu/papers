In the previous paper \cite{Denghang2023}, we naively unwind the counting operators when they are in other counting or complement operator. However, this approach is not efficient when the counting bounds are large. In this section, we present some heuristics to solve the RECL constraints more efficiently.

\subsection{Heuristic for RECL Constraints with Nested Counting}\label{heuristic:nested}
 The naive approach for nested counting in the paper \cite{Denghang2023} is to unwind all inner counting operators. This approach may generate a large number of states, which is linear to the product of the counting bounds in regex and exponential to the length of the regex. For example, naive unwinding regex $(a^{\{1,1000\}})^{\{1,2\}}$ generate a CEFA containing 1000 states. But if we only unwind the outer counting operator of the regex, not inner, we obtain a CEFA containing only 2 states. The side effect is that we need two registers to store the information of conuting in the inner regex (unwinding of outer counting operator repeat the inner regex, which also repeat the registers of the inner regex).We present a heuristic to reduce the number of states generated by the unwinding process. The idea is to unwind the counting operator with less bound and less side effect firstly. We present the heuristic in the following algorithm.

\medskip
\noindent
\emph{Step 1. (Compute the number of states generated by each counting operator if we unwind it).}

For a regex $\regex$, we can approximate the number of states $size(\regex)$ generated by the following formula: 
\begin{itemize}
  \item If $\regex = \emptyset$ or $\regex = \epsilon$, then $size(\regex) = 0$. 
  \item If $\regex = \regex_1 \cdot \regex_2$ or $\regex = \regex_1 + \regex_2$, then $size(\regex) = size(\regex_1) + size(\regex_2)$.
  \item If $\regex = \regex_1^*$, then $size(\regex) = size(\regex_1)$.
  \item If $\regex = \regex_1 \cap \regex_2$, then $size(\regex) = size(\regex_1)*size(\regex_2)$.
  \item If $\regex = \overline{\regex_1}$, then $size(\regex) = 2^{size(\regex_1)} + 1$.
  \item $\regex = \regex_1 \backslash \regex_2$ can be transfered to $\regex = \regex_1 \cap \overline{\regex_2}$ and then the size can be computed by the formula of $\cap$ and $\bar{}$.
  \item For $\regex = \regex_1^{\{n,m\}}$ or $\regex = \regex_1^{\{m,\infty\}}$, $size(\regex)$ is equal to $m*size(\regex_1)$ if it is unwinded, and $size(\regex_1)$ otherwise.
\end{itemize}

For each counting operator $^{\{n,m\}}$ or $^{\{m,\infty\}}$ with $\regex$ as its subregex, the number of states generated by it is $m*size(\regex)$ if we unwind it.

The formula above is an approximation of the states of CEFA generated by Thompson's construction. Note that the number of states is linear to the bound for the counting operator.

\medskip
\noindent
\emph{Step 2. (Compute the number of registers generated by each counting operator if we unwind it).}

We unwind the counting operator with less bound first. The reason is that the number of states generated by the counting operator is linear to its bound. If we unwind the counting operator with less bound first, the number of states generated by the unwinding process is less. However, the hardness of solving the $\cefadec$ problem is not only relevant to the number of states, but also the number of registers. For a regex $\regex$, we can approximate the number of registers $reg(\regex)$ generated by the following formula:
\begin{itemize}
  \item If $\regex = \emptyset$, $\regex = \epsilon$, $\regex = \regex_1^*$ or $\regex = \overline{\regex_1}$, then $reg(\regex) = 0$.
  \item If $\regex = \regex_1\cdot \regex_2$ or $\regex = \regex_1 \cap \regex_2$, then $reg(\regex) = reg(\regex_1) + reg(\regex_2)$.
  \item If $\regex = \regex_1 + \regex_2$, then $reg(\regex) = reg(\regex_1) + reg(\regex_2) + 1$.
  \item $\regex = \regex_1 \backslash \regex_2$ can be transfered to $\regex = \regex_1 \cap \overline{\regex_2}$ and then the number of registers can be computed by the formula of $\cap$ and $\bar{}$.
  \item For $\regex = \regex_1^{\{n,m\}}$ or $\regex = \regex^{\{m, \infty\}}$, $reg(\regex)$ is equal to $m*reg(\regex_1)$ if it is unwinded, and $1$ otherwise.
\end{itemize}

For each counting operator $^{\{n,m\}}$ or $^{\{m,\infty\}}$ with $\regex$ as its subregex, the number of registers generated by it is $m*reg(\regex)$ if we unwind it.

\medskip
\noindent
\emph{Step 3. (Unwind the counting operator with less bound and less registers first).}

In the above two steps, we compute the number of states and registers generated by each counting operator. In some cases, we can unwind the counting operator with less bound and less registers directly. But in most cases, there are multiple counting operators where one counting operator has less bound and another counting operator has less registers. To consider the number of states and registers at the same time, we can compute the score of each counting operator by the following formula:
\begin{itemize}
  \item $score(\regex) = size(\regex) * (reg(\regex)+1)$.
\end{itemize} 
The reason why we use product to combine the two factors is that the hardness of the $\cefadec$ problem is highly relevant to the number of variables in the final existential LIA formula, which is linear to the product of the number of states and the number of registers. Use $reg(\regex) + 1$ not $reg(\regex)$ is because the registers number may be $0$.We unwind the counting operator with the smallest score first. 

\begin{example}
  Consider the regex $(a^{\{1,1000\}})^{\{1,2\}}$. The score of $^{\{1,1000\}}$ is $1000*(0+1) = 1000$ and the score of $^{\{1,2\}}$ is $2*(2+1) = 6$. We unwind the outer counting operator first and obtain a CEFA containing only 2 states.  
\end{example}

\subsection{Heuristic for RECL Constraints with Complement on Counting}
As we mentioned in the above section \ref{heuristic:nested}, the unwinding process of the complement operator is exponential to the counting bounds in the worst case. We present a heuristic to reduce the number of states generated by the unwinding process. The idea is to under-approximate and over-approximate the language of the regex first, so that we can avoid unwinding counting operators in complement. We present the heuristic in the following algorithm.

\medskip
\noindent
\emph{Step 1. (Under-approximate the language of the regex with complement operators).}

The under-approximation is replacing each counting operator in the subregex of complement with a Kleene star operator. The language of the subregex is a superset of the language of it after under-approximation. In sequential, the complement of the subregex is a subset of origin. Note that this approach only works for non-nested complement, which means there is no other complement operators in the complement. For nested complement,  we naively handle the inner complement operators as paper \cite{Denghang2023} and then under-approximate the outer complement operator.

\medskip
\noindent
\emph{Step 2. (Over-approximate the language of the regex with complement operators).}

The over-approximation is to "complement" the CEFA of the subregex directly, without unwinding the counting operators in the subregex. The over-approximated complementary algorithm for CEFA is as follows:

Given a CEFA $\aut = (R, Q, \Sigma, \delta, I, F, \alpha)$, the over-approximated complement of it is a tuple $(R\cup\{r\}, Q\cup\{s,f\}, \Sigma, \delta', I, (Q\cup\{s,f\})\backslash F, \alpha')$, where :
\begin{itemize}
  \item $r$ is a new regesiter not in $R$.
  \item $s$ and $f$ are two new states not in $Q$.
  \item $\delta'$ is a transitions set containing all transitions in $\delta$ and transitions from each state $q$ in $Q$ to $s$ with label $a$ if there is no transitions from $q$ to any state with label $a$ in $\aut$. To be more detailed, $\delta'$ is the union of four sets:
  \begin{itemize}
    \item $\{(q, a, q',(\vec{v}, \vec{0})) \mid (q, a, q', \vec{v})\in \delta\}$
    \item $\{(q, a, s,(\vec{0}, \vec{0})) \mid \forall q'\in Q,\vec{v}. (q, a, q', \vec{v})\not\in \delta\}$
    \item $\{(q, a, f,(\vec{v}, \vec{1})) \mid \exists q'\in F, (q, a, q', \vec{v})\in \delta\}$
    \item $\{(s, \Sigma, s, (\vec{0}, \vec{0}))\}$
  \end{itemize}
  \item $\alpha'$ is $r \not= 1\vee \neg \alpha$
\end{itemize}

$r$ is the register used to check whether the accepted state is also accepted in the original CEFA. $s$ is the self loop state accepting all string that is not accepted by the original CEFA. $f$ is the merged accepted state of original CEFA. If there is a transition $(q, a, q', \vec{v})$ teminates at the accepted state $q'$ in the original CEFA, we add a corresponding transition $(q, a, f, (\vec{v}, \vec{1}))$ in the over-approximated complement. From the definition of $\delta'$, we can see that only the transitions goto $f$ increase the value of regesiter $r$. The value of $r$ is $1$ if and only if the accepted state is also accepted in the original CEFA. With above construction, the meaning of the accepting condition $\alpha'$ is obvious: If the string teminates at the accepting state in the original CEFA, then the accepting condition $\alpha$ is false.

\begin{theorem}
  The language of over-approximated complement of CEFA is a superset of the language of exact complement.
\end{theorem}
\begin{proof}
   Suppose that the original CEFA is $\aut = (R, Q, \Sigma, \delta, I, F, \alpha)$, the over-approximated complement of it is $\overline{\aut}_{over} = (R\cup\{r\}, Q\cup\{s,f\}, \Sigma, \delta', I, (Q\cup\{s,f\})\backslash F, \alpha')$, and the exact complement of it is $\overline{\aut}$. To prove the theorem, we only need to show that if a string is accepted by $\overline{\aut}$, then it is accepted by $\overline{\aut}_{over}$. In other words, we need to show that if a string is not accepted by $\overline{\aut}_{over}$, then it is not accepted by $\overline{\aut}$, which means it is accepted by $\aut$. We prove it by construction.
   
   In the definition of CEFA in section \ref{sec:automaton}, a run $q_0 \xrightarrow[\myvec{\overline{v}_1}]{a_1} q_1 \cdots q_{n-1}\xrightarrow[\myvec{\overline{v}_n}]{a_n} q_n$ is \emph{accepting} by $\overline{\aut}_{over}$ if $q_n \in (Q\cup\{s,f\})\backslash F$ and $\alpha'(\myvec{\overline{v}'}/(R\cup\{r\}))$ is true, where $\myvec{\overline{v}'} = \sum \limits_{j \in [n]} \myvec{\overline{v}_j}$. If a string is not accepted by $\overline{\aut}_{over}$, then each run of the string is not accepting run, which means the run teminates at state $q\in F$ or the accepting condition $\alpha'(\myvec{\overline{v}'}/(R\cup\{r\}))$ is $false$. 
   
   If each run teminates at state $q_f\in F$, suppose that each is of form $q_0\xrightarrow[(\myvec{v_1},\myvec{0})]{a_1}q_1\cdots q_{n-1}\xrightarrow[(\myvec{v_n},\myvec{0})]{a_n}q_f$, where $\myvec{\overline{v}_i}$ is $(\myvec{v_i}, \myvec{0})$ or $(\myvec{v_i}, \myvec{1})$ for $1\leq i\leq n$. Then there is a transition $(q_{n-1}, a_n, q_f, \myvec{v_n})$ in $\delta$ because there is a transition $(q_{n-1}, a_n, q_f, (\myvec{v_n}, \myvec{0}))$ in $\delta'$. So there is a transition $(q_{n-1}, a_n, f, (\myvec{v_n}, \myvec{1}))$ in $\delta'$ based on our construction for $\delta'$. The run $q_0\xrightarrow[(\myvec{v_1},\myvec{0})]{a_1}q_1\cdots q_{n-1}\xrightarrow[(\myvec{v_n},\myvec{1})]{a_n}f$ teminates at the accepting state $f$, contridicting the assumption. 
   
   If each run makes the accepting condition $\alpha'(\myvec{\overline{v}'}/(R\cup\{r\}))$ false, then the negation of the accepting condition $\neg\alpha'(\myvec{\overline{v}'}/(R\cup\{r\}))$ is true. The negation can be rewriten to $(r=1\wedge \alpha)(\myvec{\overline{v}'}/(R\cup\{r\})) = (r=1)(\myvec{\overline{v}'}/(R\cup\{r\}))\wedge \alpha(\myvec{\overline{v}'}/(R\cup\{r\}))$. In our construction, only the transitions teminate at $f$ increase one to the value of $r$, so that the run must end at $f$ to make $r=1$ be true. $\alpha(\myvec{\overline{v}'}/(R\cup\{r\})) = \alpha(\myvec{v'}/R)$ is also need to be true, implying that the run is an accepting run of $\aut$.
\end{proof}

\subsection{Heuristic for Finding an Accepted Word}
In the section \ref{sec:algorithm}, we present an algorithm to solve the $\cefadec$ problem. The algorithm computes existential LIA formulas and then uses SMT solver to solve it. However, this procedure only anwser the question whether the language of the regex is empty or not. If the language is not empty, we need to find a word in the language in practice. In our preivous paper \cite{Denghang2023}, we do not explicitly present the algorithm to find a word in the language because of the space limitation. We have used a naive approach which randomly searching the CEFAs by the depth-first search, based on the regesiters values obtained from solving the existential LIA formula. However, this approach is not efficient. Suppose that there are $n$ registers whose values are $r_1,\cdots, r_n$ respectively in the CEFA, we may visit each transition $O(r_1*r_2\cdots *r_n)$ times during the search. To relieve this problem, we present a heuristic to find a word in the language as follows.

\medskip
\noindent
\emph{Step 1. (Compute the transitions times visited by the accepted string of CEFAs).}

For each CEFA $\aut = (R, Q, \Sigma, \delta, I, F, \alpha)$, we already know the values of its registers after solving the existential LIA formula. The values can be seen as a constant vector of length $|R|$. We use $\myvec{R}$ to denote the vector and use $\eta((q, a, q', \myvec{v}))$ to denote the parikh image of $\aut$. Then the transitions times visited by the accepted stirng is obtained from the following formula:
$$ \sum \limits_{(q, a, q', \myvec{v})\in \delta} \eta((q, a, q', \myvec{v}))\myvec{v} = \myvec{R}$$

\medskip
\noindent
\emph{Step 2. (Prune the search tree early by the transitions times during the search process).}

After computing the transitions times visited by the accepted string, we prune the search tree of the CEFA based on the transitions times. The idea is that we only visit the state which is able to reach all transitions need to be visited. Other states are deleted from the CEFA so that we can reduce the search space.
Note that the transitions times is updated during the search process so the search space is reduced dynamically. The presudo code is presented in Algorithm~\ref{alg:findword}.

\begin{algorithm}[H]
  \caption{Find a word in the language of a CEFA}\label{alg:findword}
  \begin{algorithmic}[1]
  \Procedure{findmodel}{$\aut,tmap$}
  % \State \Comment{$tmap$ maps transition to its remaining visited times}
      \State $todo \gets Stack(\aut_{init}, tmap, '''')$
      \State $visited \gets \emptyset$
      % \State \Comment{a stack of state, remaining visited times and word}
      \While{$todo$ is not empty}
        \State $(q, tmap, w) \gets todo.pop()$
        \If{$q\in \aut_{final}$ and $tmap.values = \myvec{0}$}
          \State \Return $w$
        \EndIf
        
        \For{each transition $(q, a, q', \myvec{v})$ where $tmap[(q, a, q', \myvec{v})]>0$}
          \State $tmap'[(q, a, q', \myvec{v})] \gets tmap[(q, a, q', \myvec{v})] - 1$
          \If{$(q', tmap')\not\in visited$ \textbf{and} \textsc{isReachable}($\aut, q', tmap'$)}
            \State $todo.push((q', tmap', w\cdot a))$
            \State $visited.add((q', tmap'))$
          \EndIf
        \EndFor
      \EndWhile
      \State \Return $\emptyset$ 
  \EndProcedure
  \end{algorithmic}
  \end{algorithm}

  The procedure \textsc{findmodel} takes a CEFA $\aut$ and a transitions-times map $tmap$ as input. $tmap$ maps each transition to its remaining visited times. Stack $todo$ contains states need to be visited, their corresponding transitions-times maps and current word. Set $visited$ is used to store the visited state with corresponding map. $todo$ is initialized with the initial state of the CEFA, the input map $tmap$ and an empty word (line 2). $visited$ is initialized as an empty set (line 3).
  In the while loop from line 4 to line 16, the state combined with its transitions-times map is searched by the depth-first search algorithm. During the search process, the procedure returns the word if the state is an accepting state and all remaining times of transitions are $0$ (line 7). For each transition $(q, a, q', \myvec{v})$ whose remaining times are greater than $0$, the procedure decreases the remaining times by $1$ (line 10) and checks whether $(q', tmap')$ is not visited and $tmap'$ is reachable from $q'$ (line 11). We say that \textit{$tmap'$ is reachable from $q'$} if each transition $t$ with $tmap'(t)> 0$ are reachable from the state $q'$. The reachability check (Algorithm~\ref{alg:isReachable}) is vital to prune the search space and reduce the search time . If the state $q'$ is not visited and $tmap'$ is reachable from $q'$, then we push $(q', tmap', w\cdot a)$ to $todo$ and add $(q', tmap')$ to $visited$ to continue the search(line 12-13). If the while loop terminates without finding an accepting word, the procedure returns $\emptyset$ (line 17).  
  
  \begin{algorithm}[H]
    \caption{Check whether the map is reachable from the state}\label{alg:isReachable}
    \begin{algorithmic}[1]
      \Procedure{isReachable}{$\aut, q, tmap$}
      \State $todo \gets Stack(q)$
      \State $visited \gets \emptyset$
      \State $qreach \gets \emptyset$
      \While{$todo$ is not empty}
        \State $q \gets todo.pop()$
        \State $visited.add(q)$
        \For{each transition $t=(q,a,q',\myvec{v})$ where $tmap(t)>0$}
          \State $qreach.add(t)$
          \If{$q'\not\in visited$}
            \State $todo.push(q')$
          \EndIf
        \EndFor
      \EndWhile
      \State Select all transitions $t$ where $tmap(t)>0$ to set $T$
      \If{$T\subseteq qreach$}
        \State \Return \textit{true}  
      \Else 
        \State \Return \textit{false}
      \EndIf
      \EndProcedure
    \end{algorithmic}
  \end{algorithm}

  In Algorithm~\ref{alg:isReachable}, all transitions reachable from the state $q'$ is computed and saved to $qreach$. If $qreach$ covers all transitions with positive times in the input map $tmap$, then we say that $tmap$ is reachable from $q'$ and the procedure \textsc{isReachable} returns true, otherwise it returns false.  