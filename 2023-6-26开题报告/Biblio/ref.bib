%---------------------------------------------------------------------------%
%-                                                                         -%
%-                             Bibliography                                -%
%-                                                                         -%
%---------------------------------------------------------------------------%
@article{repalceall_decidable,
  author     = {Chen, Taolue and Chen, Yan and Hague, Matthew and Lin, Anthony W. and Wu, Zhilin},
  title      = {What is Decidable about String Constraints with the ReplaceAll Function},
  year       = {2017},
  issue_date = {January 2018},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {2},
  number     = {POPL},
  url        = {https://doi.org/10.1145/3158091},
  doi        = {10.1145/3158091},
  abstract   = {The theory of strings with concatenation has been widely argued as the basis of constraint solving for verifying string-manipulating programs. However, this theory is far from adequate for expressing many string constraints that are also needed in practice; for example, the use of regular constraints (pattern matching against a regular expression), and the string-replace function (replacing either the first occurrence or all occurrences of a ``pattern'' string constant/variable/regular expression by a ``replacement'' string constant/variable), among many others. Both regular constraints and the string-replace function are crucial for such applications as analysis of JavaScript (or more generally HTML5 applications) against cross-site scripting (XSS) vulnerabilities, which motivates us to consider a richer class of string constraints. The importance of the string-replace function (especially the replace-all facility) is increasingly recognised, which can be witnessed by the incorporation of the function in the input languages of several string constraint solvers. Recently, it was shown that any theory of strings containing the string-replace function (even the most restricted version where pattern/replacement strings are both constant strings) becomes undecidable if we do not impose some kind of straight-line (aka acyclicity) restriction on the formulas. Despite this, the straight-line restriction is still practically sensible since this condition is typically met by string constraints that are generated by symbolic execution. In this paper, we provide the first systematic study of straight-line string constraints with the string-replace function and the regular constraints as the basic operations. We show that a large class of such constraints (i.e. when only a constant string or a regular expression is permitted in the pattern) is decidable. We note that the string-replace function, even under this restriction, is sufficiently powerful for expressing the concatenation operator and much more (e.g. extensions of regular expressions with string variables). This gives us the most expressive decidable logic containing concatenation, replace, and regular constraints under the same umbrella. Our decision procedure for the straight-line fragment follows an automata-theoretic approach, and is modular in the sense that the string-replace terms are removed one by one to generate more and more regular constraints, which can then be discharged by the state-of-the-art string constraint solvers. We also show that this fragment is, in a way, a maximal decidable subclass of the straight-line fragment with string-replace and regular constraints. To this end, we show undecidability results for the following two extensions: (1) variables are permitted in the pattern parameter of the replace function, (2) length constraints are permitted.},
  journal    = {Proc. ACM Program. Lang.},
  month      = {dec},
  articleno  = {3},
  numpages   = {29},
  keywords   = {ReplaceAll, Decision Procedures, String Constraints, Straight-Line Programs, Constraint Solving}
}
@article{ostrich,
  author     = {Chen, Taolue and Hague, Matthew and Lin, Anthony W. and R\"{u}mmer, Philipp and Wu, Zhilin},
  title      = {Decision Procedures for Path Feasibility of String-Manipulating Programs with Complex Operations},
  year       = {2019},
  issue_date = {January 2019},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {3},
  number     = {POPL},
  url        = {https://doi.org/10.1145/3290362},
  journal    = {Proc. ACM Program. Lang.},
  month      = {jan},
  articleno  = {49},
  numpages   = {30},
  keywords   = {Reverse, Decision Procedures, Transducers, ReplaceAll, Straight-Line Programs, String Constraints}
}
@inproceedings{ostrich_atva,
  author    = {Taolue Chen and
               Matthew Hague and
               Jinlong He and
               Denghang Hu and
               Anthony Widjaja Lin and
               Philipp R{\"{u}}mmer and
               Zhilin Wu},
  editor    = {Dang Van Hung and
               Oleg Sokolsky},
  title     = {A Decision Procedure for Path Feasibility of String Manipulating Programs
               with Integer Data Type},
  booktitle = {Automated Technology for Verification and Analysis - 18th International
               Symposium, {ATVA} 2020, Hanoi, Vietnam, October 19-23, 2020, Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {12302},
  pages     = {325--342},
  publisher = {Springer},
  year      = {2020},
  url       = {https://doi.org/10.1007/978-3-030-59152-6_18}
}
@article{ostrich_greedy,
  author     = {Taolue Chen and
                Alejandro Flores{-}Lamas and
                Matthew Hague and
                Zhilei Han and
                Denghang Hu and
                Shuanglong Kan and
                Anthony Widjaja Lin and
                Philipp R{\"{u}}mmer and
                Zhilin Wu},
  title      = {Solving String Constraints With Regex-Dependent Functions Through
                Transducers With Priorities And Variables},
  journal    = {CoRR},
  volume     = {abs/2111.04298},
  year       = {2021},
  url        = {https://doi.org/10.1145/3498707},
  eprinttype = {arXiv},
  eprint     = {2111.04298},
  timestamp  = {Fri, 26 Nov 2021 09:45:16 +0100},
  biburl     = {https://dblp.org/rec/journals/corr/abs-2111-04298.bib},
  bibsource  = {dblp computer science bibliography, https://dblp.org}
}

@InProceedings{z3,
author="de Moura, Leonardo
and Bj{\o}rner, Nikolaj",
editor="Ramakrishnan, C. R.
and Rehof, Jakob",
title="Z3: An Efficient SMT Solver",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="337--340",
abstract="Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first order formulas with respect to combinations of background theories such as: arithmetic, bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver freely available from Microsoft Research. It is used in various software verification and analysis applications.",
isbn="978-3-540-78800-3"
}
@inproceedings{z3str,
  author    = {Zheng, Yunhui and Zhang, Xiangyu and Ganesh, Vijay},
  title     = {Z3-Str: A Z3-Based String Solver for Web Application Analysis},
  year      = {2013},
  isbn      = {9781450322379},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2491411.2491456},
  doi       = {10.1145/2491411.2491456},
  abstract  = {Analyzing web applications requires reasoning about strings and non-strings cohesively. Existing string solvers either ignore non-string program behavior or support limited set of string operations. In this paper, we develop a general purpose string solver, called Z3-str, as an extension of the Z3 SMT solver through its plug-in interface. Z3-str treats strings as a primitive type, thus avoiding the inherent limitations observed in many existing solvers that encode strings in terms of other primitives. The logic of the plug-in has three sorts, namely, bool, int and string. The string-sorted terms include string constants and variables of arbitrary length, with functions such as concatenation, sub-string, and replace. The int-sorted terms are standard, with the exception of the length function over string terms. The atomic formulas are equations over string terms, and (in)-equalities over integer terms. Not only does our solver have features that enable whole program symbolic, static and dynamic analysis, but also it performs better than other solvers in our experiments. The application of Z3-str in remote code execution detection shows that its support of a wide spectrum of string operations is key to reducing false positives.},
  booktitle = {Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering},
  pages     = {114–124},
  numpages  = {11},
  keywords  = {Web Application, String Constraint Solver, String Analysis},
  location  = {Saint Petersburg, Russia},
  series    = {ESEC/FSE 2013}
}

@inproceedings{z3str2,
  author    = {Zheng, Yunhui
               and Ganesh, Vijay
               and Subramanian, Sanu
               and Tripp, Omer
               and Dolby, Julian
               and Zhang, Xiangyu},
  editor    = {Kroening, Daniel
               and P{\u{a}}s{\u{a}}reanu, Corina S.},
  title     = {Effective Search-Space Pruning for Solvers of String Equations, Regular Expressions and Length Constraints},
  booktitle = {Computer Aided Verification},
  year      = {2015},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {235--254},
  abstract  = {In recent years, string solvers have become an essential component in many formal-verification, security-analysis and bug-finding tools. Such solvers typically support a theory of string equations, the length function as well as the regular-expression membership predicate. These enable considerable expressive power, which comes at the cost of slow solving time, and in some cases even nontermination. We present two techniques, designed for word-based SMT string solvers, to mitigate these problems: (i) sound and complete detection of overlapping variables, which is essential to avoiding common cases of nontermination; and (ii) pruning of the search space via bi-directional integration between the string and integer theories, enabling new cross-domain heuristics. We have implemented both techniques atop the Z3-str solver, resulting in a significantly more robust and efficient solver, dubbed Z3str2, for the quantifier-free theory of string equations, the regular-expression membership predicate and linear arithmetic over the length function. We report on a series of experiments over four sets of challenging real-world benchmarks, where we compared Z3str2 with five different string solvers: S3, CVC4, Kaluza, PISA and Stranger. Each of these tools utilizes a different solving strategy and/or string representation (based e.g. on words, bit vectors or automata). The results point to the efficacy of our proposed techniques, which yield dramatic performance improvement. We argue that the techniques presented here are of broad applicability, and can be integrated into other SMT-backed string solvers to improve their performance.			},
  isbn      = {978-3-319-21690-4}
}
@inproceedings{z3str3,
  author    = {Berzish, Murphy and Ganesh, Vijay and Zheng, Yunhui},
  title     = {Z3str3: A String Solver with Theory-Aware Heuristics},
  year      = {2017},
  isbn      = {9780983567875},
  publisher = {FMCAD Inc},
  address   = {Austin, Texas},
  abstract  = {We present a new string SMT solver, Z3str3, that is faster than its competitors Z3str2, Norn, CVC4, S3, and S3P over a majority of three industrial-strength benchmarks, namely, Kaluza, PISA, and IBM AppScan. Z3str3 supports string equations, linear arithmetic over length function, and regular language membership predicate. The key algorithmic innovation behind the efficiency of Z3str3 is a technique we call theory-aware branching, wherein we modify Z3's branching heuristic to take into account the structure of theory literals to compute branching activities. In the traditional DPLL(T) architecture, the structure of theory literals is hidden from the DPLL(T) SAT solver because of the Boolean abstraction constructed over the input theory formula. By contrast, the theory-aware technique presented in this paper exposes the structure of theory literals to the DPLL(T) SAT solver's branching heuristic, thus enabling it to make much smarter decisions during its search than otherwise. As a consequence, Z3str3 has better performance than its competitors.},
  booktitle = {Proceedings of the 17th Conference on Formal Methods in Computer-Aided Design},
  pages     = {55–59},
  numpages  = {5},
  location  = {Vienna, Austria},
  series    = {FMCAD '17}
}
@inproceedings{z3str3re,
  author    = {Berzish, Murphy
               and Kulczynski, Mitja
               and Mora, Federico
               and Manea, Florin
               and Day, Joel D.
               and Nowotka, Dirk
               and Ganesh, Vijay},
  editor    = {Silva, Alexandra
               and Leino, K. Rustan M.},
  title     = {An SMT Solver for Regular Expressions and Linear Arithmetic over String Length},
  booktitle = {Computer Aided Verification},
  year      = {2021},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {289--312},
  abstract  = {We present a novel length-aware solving algorithm for the quantifier-free first-order theory over regex membership predicate and linear arithmetic over string length. We implement and evaluate this algorithm and related heuristics in the Z3 theorem prover. A crucial insight that underpins our algorithm is that real-world regex and string formulas contain a wealth of information about upper and lower bounds on lengths of strings, and such information can be used very effectively to simplify operations on automata representing regular expressions. Additionally, we present a number of novel general heuristics, such as the prefix/suffix method, that can be used to make a variety of regex solving algorithms more efficient in practice. We showcase the power of our algorithm and heuristics via an extensive empirical evaluation over a large and diverse benchmark of 57256 regex-heavy instances, almost 75{\%} of which are derived from industrial applications or contributed by other solver developers. Our solver outperforms five other state-of-the-art string solvers, namely, CVC4, OSTRICH, Z3seq, Z3str3, and Z3-Trau, over this benchmark, in particular achieving a speedup of 2.4{\$}{\$}{\backslash}times {\$}{\$}{\texttimes}over CVC4, 4.4{\$}{\$}{\backslash}times {\$}{\$}{\texttimes}over Z3seq, 6.4{\$}{\$}{\backslash}times {\$}{\$}{\texttimes}over Z3-Trau, 9.1{\$}{\$}{\backslash}times {\$}{\$}{\texttimes}over Z3str3, and 13{\$}{\$}{\backslash}times {\$}{\$}{\texttimes}over OSTRICH.},
  isbn      = {978-3-030-81688-9}
}

@inproceedings{cvc4_2014,
  author    = {Liang, Tianyi
               and Reynolds, Andrew
               and Tinelli, Cesare
               and Barrett, Clark
               and Deters, Morgan},
  editor    = {Biere, Armin
               and Bloem, Roderick},
  title     = {A DPLL(T) Theory Solver for a Theory of Strings and Regular Expressions},
  booktitle = {Computer Aided Verification},
  year      = {2014},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {646--662},
  abstract  = {An increasing number of applications in verification and security rely on or could benefit from automatic solvers that can check the satisfiability of constraints over a rich set of data types that includes character strings. Unfortunately, most string solvers today are standalone tools that can reason only about (some fragment) of the theory of strings and regular expressions, sometimes with strong restrictions on the expressiveness of their input language. These solvers are based on reductions to satisfiability problems over other data types, such as bit vectors, or to automata decision problems. We present a set of algebraic techniques for solving constraints over the theory of unbounded strings natively, without reduction to other problems. These techniques can be used to integrate string reasoning into general, multi-theory SMT solvers based on the DPLL(T) architecture. We have implemented them in our SMT solver cvc4 to expand its already large set of built-in theories to a theory of strings with concatenation, length, and membership in regular languages. Our initial experimental results show that, in addition, over pure string problems, cvc4 is highly competitive with specialized string solvers with a comparable input language.},
  isbn      = {978-3-319-08867-9}
}
@inproceedings{cvc4_2017,
  author    = {Andrew Reynolds and
               Maverick Woo and
               Clark W. Barrett and
               David Brumley and
               Tianyi Liang and
               Cesare Tinelli},
  editor    = {Rupak Majumdar and
               Viktor Kuncak},
  title     = {Scaling Up {DPLL(T)} String Solvers Using Context-Dependent Simplification},
  booktitle = {Computer Aided Verification - 29th International Conference, {CAV}
               2017, Heidelberg, Germany, July 24-28, 2017, Proceedings, Part {II}},
  series    = {Lecture Notes in Computer Science},
  volume    = {10427},
  pages     = {453--474},
  publisher = {Springer},
  year      = {2017},
  url       = {https://doi.org/10.1007/978-3-319-63390-9\_24},
  doi       = {10.1007/978-3-319-63390-9\_24},
  timestamp = {Tue, 27 Jul 2021 08:54:13 +0200},
  biburl    = {https://dblp.org/rec/conf/cav/ReynoldsWBBLT17.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{cvc4_2019,
  author    = {Andrew Reynolds and
               Andres N{\"{o}}tzli and
               Clark W. Barrett and
               Cesare Tinelli},
  editor    = {Isil Dillig and
               Serdar Tasiran},
  title     = {High-Level Abstractions for Simplifying Extended String Constraints
               in {SMT}},
  booktitle = {Computer Aided Verification - 31st International Conference, {CAV}
               2019, New York City, NY, USA, July 15-18, 2019, Proceedings, Part
               {II}},
  series    = {Lecture Notes in Computer Science},
  volume    = {11562},
  pages     = {23--42},
  publisher = {Springer},
  year      = {2019},
  url       = {https://doi.org/10.1007/978-3-030-25543-5\_2},
  doi       = {10.1007/978-3-030-25543-5\_2},
  timestamp = {Tue, 27 Jul 2021 08:54:13 +0200},
  biburl    = {https://dblp.org/rec/conf/cav/ReynoldsNBT19.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{cvc4_2020,
  author    = {Reynolds, Andrew and Notzlit, Andres and Barrett, Clark and Tinelli, Cesare},
  booktitle = {2020 Formal Methods in Computer Aided Design (FMCAD)},
  title     = {Reductions for Strings and Regular Expressions Revisited},
  year      = {2020},
  volume    = {},
  number    = {},
  pages     = {225-235},
  doi       = {10.34727/2020/isbn.978-3-85448-042-6_30}
}

@inproceedings{trau_2017,
  author    = {Abdulla, Parosh Aziz and Atig, Mohamed Faouzi and Chen, Yu-Fang and Diep, Bui Phi and Hol\'{\i}k, Luk\'{a}\v{s} and Rezine, Ahmed and R\"{u}mmer, Philipp},
  title     = {Flatten and Conquer: A Framework for Efficient Analysis of String Constraints},
  year      = {2017},
  isbn      = {9781450349888},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3062341.3062384},
  doi       = {10.1145/3062341.3062384},
  abstract  = {We describe a uniform and efficient framework for checking the satisfiability of a large class of string constraints. The framework is based on the observation that both satisfiability and unsatisfiability of common constraints can be demonstrated through witnesses with simple patterns. These patterns are captured using flat automata each of which consists of a sequence of simple loops. We build a Counter-Example Guided Abstraction Refinement (CEGAR) framework which contains both an under- and an over-approximation module. The flow of information between the modules allows to increase the precision in an automatic manner. We have implemented the framework as a tool and performed extensive experimentation that demonstrates both the generality and efficiency of our method.},
  booktitle = {Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages     = {602–617},
  numpages  = {16},
  keywords  = {String Equation, Formal Verification, Automata Theory},
  location  = {Barcelona, Spain},
  series    = {PLDI 2017}
}

@inproceedings{trau_2018,
  author    = {Abdulla, Parosh Aziz and Faouzi Atig, Mohamed and Chen, Yu-Fang and Diep, Bui Phi and Holík, Lukáš and Rezine, Ahmed and Rümmer, Philipp},
  booktitle = {2018 Formal Methods in Computer Aided Design (FMCAD)},
  title     = {Trau: SMT solver for string constraints},
  year      = {2018},
  volume    = {},
  number    = {},
  pages     = {1-5},
  doi       = {10.23919/FMCAD.2018.8602997}
}

@inproceedings{trau+,
  author    = {Abdulla, Parosh Aziz
               and Atig, Mohamed Faouzi
               and Diep, Bui Phi
               and Hol{\'i}k, Luk{\'a}{\v{s}}
               and Jank{\r{u}}, Petr},
  editor    = {Chen, Yu-Fang
               and Cheng, Chih-Hong
               and Esparza, Javier},
  title     = {Chain-Free String Constraints},
  booktitle = {Automated Technology for Verification and Analysis},
  year      = {2019},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {277--293},
  abstract  = {We address the satisfiability problem for string constraints that combine relational constraints represented by transducers, word equations, and string length constraints. This problem is undecidable in general. Therefore, we propose a new decidable fragment of string constraints, called weakly chaining string constraints, for which we show that the satisfiability problem is decidable. This fragment pushes the borders of decidability of string constraints by generalising the existing straight-line as well as the acyclic fragment of the string logic. We have developed a prototype implementation of our new decision procedure, and integrated it into in an existing framework that uses CEGAR with under-approximation of string constraints based on flattening. Our experimental results show the competitiveness and accuracy of the new framework.},
  isbn      = {978-3-030-31784-3}
}

@inproceedings{abc,
  author    = {Aydin, Abdulbaki
               and Bang, Lucas
               and Bultan, Tevfik},
  editor    = {Kroening, Daniel
               and P{\u{a}}s{\u{a}}reanu, Corina S.},
  title     = {Automata-Based Model Counting for String Constraints},
  booktitle = {Computer Aided Verification},
  year      = {2015},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {255--272},
  abstract  = {Most common vulnerabilities in Web applications are due to string manipulation errors in input validation and sanitization code. String constraint solvers are essential components of program analysis techniques for detecting and repairing vulnerabilities that are due to string manipulation errors. For quantitative and probabilistic program analyses, checking the satisfiability of a constraint is not sufficient, and it is necessary to count the number of solutions. In this paper, we present a constraint solver that, given a string constraint, (1) constructs an automaton that accepts all solutions that satisfy the constraint, (2) generates a function that, given a length bound, gives the total number of solutions within that bound. Our approach relies on the observation that, using an automata-based constraint representation, model counting reduces to path counting, which can be solved precisely. We demonstrate the effectiveness of our approach on a large set of string constraints extracted from real-world web applications.},
  isbn      = {978-3-319-21690-4}
}
@inproceedings{mult_abc,
  author    = {Aydin, Abdulbaki and Eiers, William and Bang, Lucas and Brennan, Tegan and Gavrilov, Miroslav and Bultan, Tevfik and Yu, Fang},
  title     = {Parameterized Model Counting for String and Numeric Constraints},
  year      = {2018},
  isbn      = {9781450355735},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3236024.3236064},
  doi       = {10.1145/3236024.3236064},
  abstract  = {Recently, symbolic program analysis techniques have been extended to quantitative analyses using model counting constraint solvers. Given a constraint and a bound, a model counting constraint solver computes the number of solutions for the constraint within the bound. We present a parameterized model counting constraint solver for string and numeric constraints. We first construct a multi-track deterministic finite state automaton that accepts all solutions to the given constraint. We limit the numeric constraints to linear integer arithmetic, and for non-regular string constraints we over-approximate the solution set. Counting the number of accepting paths in the generated automaton solves the model counting problem. Our approach is parameterized in the sense that, we do not assume a finite domain size during automata construction, resulting in a potentially infinite set of solutions, and our model counting approach works for arbitrarily large bounds. We experimentally demonstrate the effectiveness of our approach on a large set of string and numeric constraints extracted from software applications. We experimentally compare our tool to five existing model counting constraint solvers for string and numeric constraints and demonstrate that our tool is as efficient and as or more precise than other solvers. Moreover, our tool can handle mixed constraints with string and integer variables that no other tool can.},
  booktitle = {Proceedings of the 2018 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
  pages     = {400–410},
  numpages  = {11},
  keywords  = {constraint solving, Model counting, quantitative program analysis},
  location  = {Lake Buena Vista, FL, USA},
  series    = {ESEC/FSE 2018}
}

@article{sloth,
  author     = {Hol\'{\i}k, Luk\'{a}\v{s} and Jank\r{u}, Petr and Lin, Anthony W. and R\"{u}mmer, Philipp and Vojnar, Tom\'{a}\v{s}},
  title      = {String Constraints with Concatenation and Transducers Solved Efficiently},
  year       = {2017},
  issue_date = {January 2018},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {2},
  number     = {POPL},
  url        = {https://doi.org/10.1145/3158092},
  journal    = {Proc. ACM Program. Lang.},
  month      = {dec},
  articleno  = {4},
  numpages   = {32},
  keywords   = {Decision Procedure, String Solving, IC3, Alternating Finite Automata}
}

@inproceedings{dpll_t,
  author    = {Ganzinger, Harald
               and Hagen, George
               and Nieuwenhuis, Robert
               and Oliveras, Albert
               and Tinelli, Cesare},
  editor    = {Alur, Rajeev
               and Peled, Doron A.},
  title     = {DPLL(T): Fast Decision Procedures},
  booktitle = {Computer Aided Verification},
  year      = {2004},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {175--188},
  abstract  = {The logic of equality with uninterpreted functions (EUF) and its extensions have been widely applied to processor verification, by means of a large variety of progressively more sophisticated (lazy or eager) translations into propositional SAT. Here we propose a new approach, namely a general DPLL(X) engine, whose parameter X can be instantiated with a specialized solver SolverTfor a given theory T, thus producing a system DPLL(T). We describe this DPLL(T) scheme, the interface between DPLL(X) and SolverT, the architecture of DPLL(X), and our solver for EUF, which includes incremental and backtrackable congruence closure algorithms for dealing with the built-in equality and the integer successor and predecessor symbols. Experiments with a first implementation indicate that our technique already outperforms the previous methods on most benchmarks, and scales up very well.},
  isbn      = {978-3-540-27813-9}
}

@inproceedings{jalangi,
author = {Sen, Koushik and Kalasapur, Swaroop and Brutch, Tasneem and Gibbs, Simon},
title = {Jalangi: A Selective Record-Replay and Dynamic Analysis Framework for JavaScript},
year = {2013},
isbn = {9781450322379},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2491411.2491447},
doi = {10.1145/2491411.2491447},
abstract = {JavaScript is widely used for writing client-side web applications and is getting increasingly popular for writing mobile applications. However, unlike C, C++, and Java, there are not that many tools available for analysis and testing of JavaScript applications. In this paper, we present a simple yet powerful framework, called Jalangi, for writing heavy-weight dynamic analyses. Our framework incorporates two key techniques: 1) selective record-replay, a technique which enables to record and to faithfully replay a user-selected part of the program, and 2) shadow values and shadow execution, which enables easy implementation of heavy-weight dynamic analyses. Our implementation makes no special assumption about JavaScript, which makes it applicable to real-world JavaScript programs running on multiple platforms. We have implemented concolic testing, an analysis to track origins of nulls and undefined, a simple form of taint analysis, an analysis to detect likely type inconsistencies, and an object allocation profiler in Jalangi. Our evaluation of Jalangi on the SunSpider benchmark suite and on five web applications shows that Jalangi has an average slowdown of 26X during recording and 30X slowdown during replay and analysis. The slowdowns are comparable with slowdowns reported for similar tools, such as PIN and Valgrind for x86 binaries. We believe that the techniques proposed in this paper are applicable to other dynamic languages.},
booktitle = {Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering},
pages = {488–498},
numpages = {11},
keywords = {Dynamic Analysis, Concolic Testing, Record and Repla, JavaScript},
location = {Saint Petersburg, Russia},
series = {ESEC/FSE 2013}
}
@inproceedings{expose_2017,
author = {Loring, Blake and Mitchell, Duncan and Kinder, Johannes},
title = {ExpoSE: Practical Symbolic Execution of Standalone JavaScript},
year = {2017},
isbn = {9781450350778},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3092282.3092295},
doi = {10.1145/3092282.3092295},
abstract = {JavaScript has evolved into a versatile ecosystem for not just the web, but also a wide range of server-side and client-side applications. With this increased scope, the potential impact of bugs increases. We introduce ExpoSE, a dynamic symbolic execution engine for Node.js applications. ExpoSE automatically generates test cases to find bugs and cover as many paths in the target program as possible. We discuss the specific challenges for symbolic execution arising from the widespread use of regular expressions in such applications. In particular, we make explicit the issues of capture groups, backreferences, and greediness in JavaScript's flavor of regular expressions, and our models improve over previous work that only partially addressed these. We evaluate ExpoSE on three popular JavaScript libraries that make heavy use of regular expressions, and we report a previously unknown bug in the Minimist library.},
booktitle = {Proceedings of the 24th ACM SIGSOFT International SPIN Symposium on Model Checking of Software},
pages = {196–199},
numpages = {4},
keywords = {Symbolic execution, JavaScript, regular expressions},
location = {Santa Barbara, CA, USA},
series = {SPIN 2017}
}
@inproceedings{expose_2019,
author = {Loring, Blake and Mitchell, Duncan and Kinder, Johannes},
title = {Sound Regular Expression Semantics for Dynamic Symbolic Execution of JavaScript},
year = {2019},
isbn = {9781450367127},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3314221.3314645},
doi = {10.1145/3314221.3314645},
abstract = {Support for regular expressions in symbolic execution-based tools for test generation and bug finding is insufficient. Common aspects of mainstream regular expression engines, such as backreferences or greedy matching, are ignored or imprecisely approximated, leading to poor test coverage or missed bugs. In this paper, we present a model for the complete regular expression language of ECMAScript 2015 (ES6), which is sound for dynamic symbolic execution of the test and exec functions. We model regular expression operations using string constraints and classical regular expressions and use a refinement scheme to address the problem of matching precedence and greediness. We implemented our model in ExpoSE, a dynamic symbolic execution engine for JavaScript, and evaluated it on over 1,000 Node.js packages containing regular expressions, demonstrating that the strategy is effective and can significantly increase the number of successful regular expression queries and therefore boost coverage.},
booktitle = {Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {425–438},
numpages = {14},
keywords = {regular expressions, JavaScript, Dynamic symbolic execution, SMT},
location = {Phoenix, AZ, USA},
series = {PLDI 2019}
}
@inproceedings{aratha,
  author    = {Roberto Amadini and
               Mak Andrlon and
               Graeme Gange and
               Peter Schachte and
               Harald S{\o}ndergaard and
               Peter J. Stuckey},
  editor    = {Louis{-}Martin Rousseau and
               Kostas Stergiou},
  title     = {Constraint Programming for Dynamic Symbolic Execution of JavaScript},
  booktitle = {Integration of Constraint Programming, Artificial Intelligence, and
               Operations Research - 16th International Conference, {CPAIOR} 2019,
               Thessaloniki, Greece, June 4-7, 2019, Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {11494},
  pages     = {1--19},
  publisher = {Springer},
  year      = {2019},
  doi       = {10.1007/978-3-030-19212-9\_1},
  timestamp = {Sun, 25 Oct 2020 23:15:05 +0100},
  biburl    = {https://dblp.org/rec/conf/cpaior/AmadiniAGSSS19.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{safe,
  title={SAFE: Formal Specification and Implementation of a Scalable Analysis Framework for ECMAScript},
  author={Hongki Lee and Sooncheol Won and Joonho Jin and Junhee Cho and Sukyoung Ryu},
  year={2012}
}
@inproceedings{10.1145/2989225.2989228,
author = {Park, Changhee and Im, Hyeonseung and Ryu, Sukyoung},
title = {Precise and Scalable Static Analysis of JQuery Using a Regular Expression Domain},
year = {2016},
isbn = {9781450344456},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2989225.2989228},
doi = {10.1145/2989225.2989228},
abstract = {jQuery is the most popular JavaScript library but the state-of-the-art static analyzers for JavaScript applications fail to analyze simple programs that use jQuery. In this paper, we present a novel abstract string domain whose elements are simple regular expressions that can represent prefix, infix, and postfix substrings of a string and even their sets. We formalize the new domain in the abstract interpretation framework with abstract models of strings and objects commonly used in the existing JavaScript analyzers. For practical use of the domain, we present polynomial-time inclusion decision rules between the regular expressions and prove that the rules exactly capture the actual inclusion relation. We have implemented the domain as an extension of the open-source JavaScript analyzer, SAFE, and we show that the extension significantly improves the scalability and precision of the baseline analyzer in analyzing programs that use jQuery.},
booktitle = {Proceedings of the 12th Symposium on Dynamic Languages},
pages = {25–36},
numpages = {12},
keywords = {static analysis, regular expressions, JavaScript},
location = {Amsterdam, Netherlands},
series = {DLS 2016}
}
@article{safe_ext,
author = {Park, Changhee and Im, Hyeonseung and Ryu, Sukyoung},
title = {Precise and Scalable Static Analysis of JQuery Using a Regular Expression Domain},
year = {2016},
issue_date = {February 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {2},
issn = {0362-1340},
url = {https://doi.org/10.1145/3093334.2989228},
doi = {10.1145/3093334.2989228},
abstract = {jQuery is the most popular JavaScript library but the state-of-the-art static analyzers for JavaScript applications fail to analyze simple programs that use jQuery. In this paper, we present a novel abstract string domain whose elements are simple regular expressions that can represent prefix, infix, and postfix substrings of a string and even their sets. We formalize the new domain in the abstract interpretation framework with abstract models of strings and objects commonly used in the existing JavaScript analyzers. For practical use of the domain, we present polynomial-time inclusion decision rules between the regular expressions and prove that the rules exactly capture the actual inclusion relation. We have implemented the domain as an extension of the open-source JavaScript analyzer, SAFE, and we show that the extension significantly improves the scalability and precision of the baseline analyzer in analyzing programs that use jQuery.},
journal = {SIGPLAN Not.},
month = {nov},
pages = {25–36},
numpages = {12},
keywords = {JavaScript, static analysis, regular expressions}
}
@InProceedings{safe_str,
author="Amadini, Roberto
and Jordan, Alexander
and Gange, Graeme
and Gauthier, Fran{\c{c}}ois
and Schachte, Peter
and S{\o}ndergaard, Harald
and Stuckey, Peter J.
and Zhang, Chenyi",
editor="Legay, Axel
and Margaria, Tiziana",
title="Combining String Abstract Domains for JavaScript Analysis: An Evaluation",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2017",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="41--57",
abstract="Strings play a central role in JavaScript and similar scripting languages. Owing to dynamic features such as the eval function and dynamic property access, precise string analysis is a prerequisite for automated reasoning about practically any kind of runtime property. Although the literature presents a considerable number of abstract domains for capturing and representing specific aspects of strings, we are not aware of tools that allow flexible combination of string abstract domains. Indeed, support for string analysis is often confined to a single, dedicated string domain. In this paper we describe a framework that allows us to combine multiple string abstract domains for the analysis of JavaScript programs. It is implemented as an extension of SAFE, an open-source static analysis tool. We investigate different combinations of abstract domains that capture various aspects of strings. Our evaluation suggests that a combination of a few, simple abstract domains suffice to outperform the precision of state-of-the-art static analysis tools for JavaScript.",
isbn="978-3-662-54577-5"
}

@inproceedings{pinplay,
author = {Patil, Harish and Pereira, Cristiano and Stallcup, Mack and Lueck, Gregory and Cownie, James},
title = {PinPlay: A Framework for Deterministic Replay and Reproducible Analysis of Parallel Programs},
year = {2010},
isbn = {9781605586359},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1772954.1772958},
doi = {10.1145/1772954.1772958},
abstract = {Analysis of parallel programs is hard mainly because their behavior changes from run to run. We present an execution capture and deterministic replay system that enables repeatable analysis of parallel programs. Our goal is to provide an easy-to-use framework for capturing, deterministically replaying, and analyzing execution of large programs with reasonable runtime and disk usage. Our system, called PinPlay, is based on the popular Pin dynamic instrumentation system hence is very easy to use. PinPlay extends the capability of Pin-based analysis by providing a tool for capturing one execution instance of a program (as log files called pinballs) and by allowing Pin-based tools to run off the captured execution. Most Pintools can be trivially modified to work off pinballs thus doing their usual analysis but with a guaranteed repeatability. Furthermore, the capture/replay works across operating systems (Windows to Linux) as the pinball format is independent of the operating system. We have used PinPlay to analyze and deterministically debug large parallel programs running trillions of instructions. This paper describes the design of PinPlay and its applications for analyses such as simulation point selection, tracing, and debugging.},
booktitle = {Proceedings of the 8th Annual IEEE/ACM International Symposium on Code Generation and Optimization},
pages = {2–11},
numpages = {10},
keywords = {repeatable simulation point selection, deterministic replay, reproducible debugging, dynamic program analysis},
location = {Toronto, Ontario, Canada},
series = {CGO '10}
}
@article{valgrind,
author = {Nethercote, Nicholas and Seward, Julian},
title = {Valgrind: A Framework for Heavyweight Dynamic Binary Instrumentation},
year = {2007},
issue_date = {June 2007},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {42},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/1273442.1250746},
doi = {10.1145/1273442.1250746},
abstract = {Dynamic binary instrumentation (DBI) frameworks make it easy to build dynamic binary analysis (DBA) tools such as checkers and profilers. Much of the focus on DBI frameworks has been on performance; little attention has been paid to their capabilities. As a result, we believe the potential of DBI has not been fully exploited.In this paper we describe Valgrind, a DBI framework designed for building heavyweight DBA tools. We focus on its unique support for shadow values-a powerful but previously little-studied and difficult-to-implement DBA technique, which requires a tool to shadow every register and memory value with another value that describes it. This support accounts for several crucial design features that distinguish Valgrind from other DBI frameworks. Because of these features, lightweight tools built with Valgrind run comparatively slowly, but Valgrind can be used to build more interesting, heavyweight tools that are difficult or impossible to build with other DBI frameworks such as Pin and DynamoRIO.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {89–100},
numpages = {12},
keywords = {dynamic binary analysis, Memcheck, dynamic binary instrumentation, Valgrind, shadow values}
}

@InProceedings{not_substr,
author="Abdulla, Parosh Aziz
and Atig, Mohamed Faouzi
and Chen, Yu-Fang
and Diep, Bui Phi
and Hol{\'i}k, Luk{\'a}{\v{s}}
and Hu, Denghang
and Tsai, Wei-Lun
and Wu, Zhillin
and Yen, Di-De",
editor="Oh, Hakjoo",
title="Solving Not-Substring Constraint withFlat Abstraction",
booktitle="Programming Languages and Systems",
year="2021",
publisher="Springer International Publishing",
address="Cham",
pages="305--320",
abstract="Not-substring is currently among the least supported types of string constraints, and existing solvers use only relatively crude heuristics. Yet, not-substring occurs relatively often in practical examples and is useful in encoding other types of constraints. In this paper, we propose a systematic way to solve not-substring using based on flat abstraction. In this framework, the domain of string variables is restricted to flat languages and subsequently the whole constraints can be expressed as linear arithmetic formulae. We show that non-substring constraints can be flattened efficiently, and provide experimental evidence that the proposed solution for not-substring is competitive with the state of the art string solvers.",
isbn="978-3-030-89051-3"
}

@article{parikh,
author = {Parikh, Rohit J.},
title = {On Context-Free Languages},
year = {1966},
issue_date = {Oct. 1966},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {13},
number = {4},
issn = {0004-5411},
url = {https://doi.org/10.1145/321356.321364},
doi = {10.1145/321356.321364},
abstract = {In this report, certain properties of context-free (CF or type 2) grammars are investigated, like that of Chomsky. In particular, questions regarding structure, possible ambiguity and relationship to finite automata are considered. The following results are presented: The language generated by a context-free grammmar is linear in a sense that is defined precisely.The requirement of unambiguity—that every sentence has a unique phrase structure—weakens the grammar in the sense that there exists a CF language that cannot be generated unambiguously by a CF grammar.The result that not every CF language is a finite automaton (FA) language is improved in the following way. There exists a CF language L such that for any L′ ⊆ L, if L′ is FA, an L″ ⊆ L can be found such that L″ is also FA, L′ ⊆ L″ and L″ contains infinitely many sentences not in L′.A type of grammar is defined that is intermediate between type 1 and type 2 grammars. It is shown that this type of grammar is essentially stronger than type 2 grammars and has the advantage over type 1 grammars that the phrase structure of a grammatical sentence is unique, once the derivation is given.},
journal = {J. ACM},
month = {oct},
pages = {570–581},
numpages = {12}
}


%---------------------------------------------------------------------------%
