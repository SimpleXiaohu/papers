\newcommand{\join}{\mathsf{join}}
\newcommand{\len}{\mathsf{len}}
\newcommand{\prefix}{\mathsf{prefix}}
\newcommand{\suffix}{\mathsf{suffix}}
\newcommand{\substr}{\mathsf{substr}}
\newcommand{\concat}{\mathsf{concat}}
\newcommand{\test}{\mathsf{test}}
\newcommand{\match}{\mathsf{match}}
\newcommand{\replace}{\mathsf{replace}}
\newcommand{\replaceall}{\mathsf{replaceAll}}
\newcommand{\transducer}{\mathsf{transducer}}
\newcommand{\reverse}{\mathsf{reverse}}
\newcommand{\htmlescape}{\mathsf{htmlEscape}}
\newcommand{\mysplit}{\mathsf{split}}
\newcommand{\myjoin}{\mathsf{join}}
\newcommand{\indexof}{\mathsf{indexof}}
\newcommand{\contain}{\mathsf{contain}}
%---------------------------------------------------------------------------%
%->> Main content
%---------------------------------------------------------------------------%
\section{选题的背景及意义}

\subsection{选题背景}
硬件和软件的飞速发展让通用计算机的能力得到极大提高，使得字符串约束的求解从不可能变为可能。同时，随着可满足性模理论（Satisfiability Modulo Theories）和符号执行技术的发展，字符串约束求解技术越来越被学术界和工业界重视，广泛应用到JavaScript符号执行引擎上。然而，现存的字符串求解器使用不完备的算法，不能很好的覆盖程序中的复杂字符串函数如$\mysplit$，不能处理数组类型，这极大地限制了字符串约束求解的能力及其在JavaScript符号执行中的应用。

目前有两种主流的字符串约束求解技术：基于自动机的约束求解技术\cite{sloth}\cite{abc} \cite{mult_abc}\cite{trau_2017}\cite{trau_2018}\cite{trau+}\cite{ostrich}和基于推导规则的求解技术\cite{z3}\cite{z3str2}\cite{z3str3}\cite{z3str3re}\cite{cvc4_2014}\cite{cvc4_2017}\cite{cvc4_2019}\cite{cvc4_2020}。前者的主要思想是将字符串约束转化为有限自动机，然后使用有限自动机已有的算法求解字符串约束。该技术的优点是模型比较经典，有丰富且可靠的理论基础。缺点是自动机求交会导致状态空间爆炸，求解效率比较低；后者的主要思想是根据每种字符串函数的具体含义，制定不同的推导规则，在DPLL(T) 框架\cite{dpll_t}下不断推导，直到找到一组变量的赋值或者推导出无解。该技术的优点是求解速度较快。缺点是算法可能不终止，不能高效处理正则表达式。

上诉求解器在字符串约束求解技术上取得了不错的成果，但是未考虑数组类型和一些实际程序中会出现的操作如$\mysplit$函数、$\myjoin$函数，也未考虑正则表达式的贪婪性。部分求解器不能处理整数数据类型。

字符串约束求解在程序分析和软件漏洞检测上有着广泛的应用，但是在JavaScript符号执行的应用还不够成熟。JavaScript符号执行技术分为静态\cite{safe} \cite{safe_ext}\cite{safe_str}和动态\cite{jalangi}\cite{expose_2017}\cite{expose_2019}\cite{aratha}两种方式。静态符号执行只针对源代码作分析，其过程首先用静态分析方法中的控制流分析构造控制流图，之后通过选取控制流图中某条路径并针对此路径作符号执行和路径约束求解。静态符号执行选取的路径中很大一部分是实际不可行路径，会导致误报。另一方面，程序代码中的分支语句的存在决定了程序的路径数向队友程序的规模呈指数型增长，导致路径爆炸问题。

动态符号执行是一种动静态结合的程序分析技术，在具体执行的同时对所执行到的代码施行符号执行，具体执行的特性决定了每次动态符号执行获取的路径都是可行路径，因此避免了误报。但是目前的SMT求解器不能很好的支持非线性算术理论，尤其是字符串理论。若程序某条分支产生的约束超过了求解器的求解能力范围，该分支会被丢掉，产生漏报。

JavaScript符号执行工具已经广泛应用上述技术，取得了一定的成果。对于数组的处理还不够完善。没有充分利用现有的字符串约束求解
器。

\subsection{选题意义}
目前没有研究者对同时含整数和数组类型的字符串约束进行系统研究，忽视了这两种数据类型在程序中的重要性。但是实际程序中这些数据类型和函数的使用频率很高，因此研究这些数据类型和函数的求解技术对于提高字符串约束求解技术的实用性和适用性具有重要意义。

JavaScript目前被广泛运用到Node.js引擎和Web应用中，有大量的使用者和开发者。但是，由于之前的字符串约束求解器没有很高的效率，也不能很全面的支持实际程序中的字符串函数和数据类型，已有的符号执行工具并没有很好地集成字符串约束。因此研究字符串约束在JavaScript符号执行中的高效应用具有前瞻意义。


\section{国内外本学科领域的发展现状与趋势}
由于硬件算力的提升，字符串约束求解技术发展迅速，相关的研究工作也越来越多，并且已经有一些JavaScript符号执行上的研究工作。本节将对字符串约束求解技术和JavaScript符号执行技术的发展现状和趋势进行介绍。
\subsection{字符串约束求解技术}
字符串约束求解技术在近年来引起了学术界和工业界的广泛关注，相关的研究工作也越来越多。目前，主流的字符串约束求解技术主要有两种：基于自动机的字符串约束求解技术和基于推导规则的字符串约束求解技术。

\paragraph{基于自动机的字符串约束求解技术}的主要思想是将字符串约束转化为自动机，然后使用自动机的理论求解字符串约束。该技术的优点是模型比较经典，有丰富且可靠的理论基础。缺点是效率比较低。目前，该技术的主要研究工作有：

2015年，Aydin等人\cite{abc}提出了字符串约束求解器ABC。ABC构造一个接受所有可能解的自动机，将字符串约束求解问题转化为自动机判空问题，然后使用现有的自动机判空算法求解。给定字符串的长度上界，ABC可以对所有长度小于等于该上界的解计数，直观地，解的个数等于自动机的接受路径数。

2018年被Aydin等人\cite{mult_abc}在ABC的基础上开发了MT-ABC。MT-ABC增加了对线性整数算术（Linear Integer Arithmetic）的支持。MT-ABC用上近似处理了非正则约束，不是一个完备的算法。ABC和MT-ABC都不支持数组类型。


2017年，Abdulla等人\cite{trau_2017}\cite{trau_2018}开发了字符串约束求解器Trau. Trau使用了反例引导的抽象精化（Counter-Example Guided Abstraction Refinement）框架。该框架的基本思想是用可满足的上近似来指导上下文无关文法的下近似，反过来若下近似不可满足，又可以精化上近似。不断迭代这个过程直到下近似找到解或者上近似返回无解。这个过程可能不终止，所以Trau是不完备的。

2019年，Abdulla等人\cite{trau+}对字符串约束的形式进行了一些限制，称为弱链式字符串约束（weakly chaining string constraints），并证明了该形式的字符串约束是可判定的，即可以在有限时间内求解且是完备的。基于此开发出字符串约束求解器Trau+。Trau和Trau+都不支持数组类型。

2018年，HOLÍK等人\cite{sloth}提出了第一个能够求解字符串连接函数和$\transducer$函数的字符串约束求解器SLOTH。SLOTH用轻量级选择自动机（Succinct Alternating Finite-state Automata）建模字符串约束，然后用模型检验算法如IC3求解。SLOTH的空间复杂度是指数级别的。SLOTH既不支持数组类型，也不支持整数数据类型。

2018年，Chen等人\cite{repalceall_decidable}研究了带有$\replaceall$函数的字符串约束的可判定性问题。$\replaceall$函数是一种字符串替换函数，它的作用是将字符串中的每个模式串替换为替代串。比如$\replaceall(\text{‘the cat is a cat’, ‘cat’, ‘dog’})$表示将字符串‘the cat is a cat’中的所有模式串‘cat’替换为替代串‘dog’，它返回字符串‘the dog is a dog’。 Chen等人提出了包含$\replaceall$函数的直线子集（Straight-Line Fragment），该直线子集包含了正则约束、字符串连接函数和$\replaceall$函数，规定字符串变量之间不存在循环依赖关系。基于该直线子集，Chen等人分三类情况讨论了带有$\replaceall$函数的字符串约束求解问题的可判定性。第一种情况是模式串为变量，该情况下是不可判定的；第二种情况是模式串为正则表达式，该情况下是可判定的且判定算法的复杂度为EXPSPACE，在某些特殊情况下复杂度可以降到PSPACE-Complete；第三种情况是模式串是常量，同时引入$\len$函数，该情况下是不可判定的。

2019年，Chen等人基于上述理论研究，开发了字符串约束求解器OSTRICH\cite{ostrich}。OSTRICH支持正则约束、字符串连接函数、$\replaceall$函数，$\transducer$函数和$\reverse$函数。$\transducer$函数是一种字符串转换函数，它将输入字符串转换为另一个字符串。比如Web程序中常用的输入过滤函数$\htmlescape$就可以用字符串转换器来定义。$\reverse$函数是一种字符串反转函数，比如$\reverse(\text{‘abc’})$返回字符串‘cba’。OSTRICH是第一个可以同时处理$\replaceall$函数和$\transducer$函数的字符串约束求解器，但是不能处理整数数据类型和数组数据类型。

% 2020年，Chen等人\cite{ostrich_atva}开发了OSTRICH+。它是OSTRICH的扩展，支持整数数据类型。OSTRICH+的基本思想是用线性整数算数公式表示OSTRICH中的自动机判空问题，再和整数数据类型结合起来。OSTRICH+的算法是完备的，但是它所处理的字符串约束中，$\replaceall$函数的模式串只能为常量。

% 为了正确处理实际程序中的贪婪匹配和非贪婪匹配，以及处理$\replaceall$函数中的反向引用，Chen等人2022年\cite{ostrich_greedy}提出了优先级流式字符串转换器（prioritized streaming string transducers）。优先级流式字符串转换器是带有优先级的字符串转换器，能够对正则表达式的贪婪性进行建模。OSTRICH+不支持数组类型。


\paragraph{基于推导规则的字符串约束求解} 的主要思想是根据字符串函数的具体含义，制定不同的推导规则，在DPLL(T)框架\cite{dpll_t}下不断推导，直到找到解或者推导出无解。该技术的优点是求解速度快，缺点是不完备，算法可能不终止，且不能高效处理正则表达式。目前，该技术的主要研究工作有：

2013年，Zheng等人\cite{z3str}基于Z3的DPLL(T)框架，首次提出了Z3\cite{z3}家族的字符串求解器Z3Str。Z3Str把字符串约束中的谓词看作布尔变量，得到一组一阶布尔逻辑公式，该公式可以用SAT求解器快速找到一组解或者返回无解。若SAT求解器成功找到一组解，那么将这组解中赋值为真的谓词提取出来，得到一个新的字符串约束，然后用Z3Str中的字符串约束推导规则进行推导，得到一组新的谓词，将其转化为布尔变量加入到原来的布尔公式中，再用SAT求解器求解。如此循环，直到找到所有字符串变量的赋值或者推导出无解。若字符串约束中的只含有字符串等式，则Z3Str的算法是完备的。

2015年，Zheng等人\cite{z3str2}在Z3Str的基础上开发了Z3Str2，添加了字符串约束和线性整数算术公式之间的启发式推导规则，对搜索空间进行剪枝，提高求解效率；并添加对字符串等式中重叠变量的探测，能够解决一部分不终止的问题。所谓字符串重叠变量，是指字符串变量同时在等式左值和右值出现，比如$axb=xa$中的$x$就是重叠变量。重叠变量是大部分求解器的一个瓶颈，因为它会导致求解器不断地推导，求解过程不终止。

2017年，Berzish等人\cite{z3str3}将Z3str2扩展为Z3Str3。Z3Str3的求解效率更高，它在SAT求解器对布尔逻辑进行规约时，不仅考虑布尔变量的取值，也考虑对应谓词中具体的字符串函数含义，可以更好地剪枝搜索空间。

2022年，Berzish等人\cite{z3str3re}为了解决Z3Str3不能高效处理正则表达式的问题，开发了求解器Z3Str3RE。Z3Str3RE不同于Z3Str3的地方在于，它把正则表达式看作一个特殊的谓词，不使用推导规则而是使用有限自动机来处理正则表达式，并且加入了一些启发式算法如自动机启发式求交、对线性约束启发式上近似等，提高了求解效率。Z3Str3RE在字符串约束只含有字符串长度函数、正则约束和线性整数算术时，求解速度非常快。Z3Str/2/3/RE能处理整数数据类型，但不能处理数组数据类型。

2014年，Liang等人\cite{cvc4_2014}与Z3团队几乎同时开发另一个基于推导规则的字符串约束求解器CVC4。CVC4的求解算法和Z3Str几乎一样，它们之间只有工程实现和推导规则上的略微差别，但是CVC4的求解效率更高。

迫于Z3Str不断更新的压力，CVC4在2017年\cite{cvc4_2017}添加了对整数数据类型和线性算术公式的支持，2019年\cite{cvc4_2019}添加了算术推导、多重集和基于算术的字符串约束简化，并在2020年\cite{cvc4_2020}对正则表达式的推导规则进行了优化，大大提高了求解效率。CVC4不支持数组类型。

上述工具在带有整数数据类型的字符串约束上已经取得不错的研究结果，但是它们对\textbf{整数和数组类型}的支持还\textbf{不够完善}，同时\textbf{没有支持$\mysplit$函数和$\myjoin$函数}。
\subsection{JavaScript符号执行技术}
近年来，JavaScript语言由于其易用性和杰出的异步处理，被广泛运用到Web应用中，JavaScript语言的符号执行技术也得到了飞速发展。JavaScript语言的符号执行技术主要有两种，一种是静态符号执行技术，一种是动态符号执行技术。

\paragraph{静态符号执行技术} 主要针对源代码作分析，主要的相关研究工作有：

2012年，Lee等人\cite{safe}提出了一个可扩展的ECMAScript语言分析框架SAFE。SAFE是第一个同时考虑了ECMAScript官方文档和其开源代码实现的分析框架，在工程上有很好的可扩展性和文档定义，尤其是对它的中间语言表示有规范的文档。SAFE支持插件式的扩展方式，用户可以方便地添加新特性。SAFE将整数数据类型和数组数据类型都编码到了SMT公式中，但编码时未完备考虑字符串函数的语义。

2016年，Park等人\cite{safe_ext}针对jQuery库中的正则表达式、字符串前缀、中缀和后缀操作进行抽象解释，扩展了JavaScript分析工具SAFE。jQuery是一个常用的开源库，但是当时存在的分析器不能分析它。Park等人使用了字符串抽象域对正则表达式和相关字符串函数进行抽象和分析，解决了这个问题。实验结果表明，使用字符串抽象域的SAFE比不使用字符串抽象域的SAFE能够分析更多的程序，分析精度更高。

2017年，Amadini等人\cite{safe_str}等人在静态程序分析工具SAFE上进行扩展，得到了工具SAFE$_{str}$。SAFE$_{str}$的主要优点在于同时使用多个字符串抽象域并用求交的方式把抽象域结合起来，结合后的抽象域更为精确。实验结果也表明在结合多个抽象域后，效率和准确度都得到了提升。

\paragraph{动态符号执行技术} 是一种动静态结合的程序分析技术，在具体执行的同时对所执行到的代码施行符号执行，主要的相关研究工作有：

2013年，Sen等人\cite{jalangi}提出了JavaScript符号执行框架Jalangi，它能够对JavaScript程序进行动态分析，包括对程序执行轨迹的记录、修改和重放，以及对程序中的语句进行插装。Jalangi能够对程序中的大部分语句进行插装，包括对字符串函数的插装，这使得它能够对含有字符串函数的程序进行动态分析。Jalangi有两个主要特点，一是有选择性地对程序进行记录和重放，而不是对程序的每一条语句都进行，这样可以大大减少程序分析时间；二是支持阴影值（shadow values）和阴影执行（shadow execution），这使得它能够使用符号执行技术和动态污点传播技术，以处理大型程序。相比于PinPlay\cite{pinplay}和Valgrind\cite{valgrind}等工具，Jalangi的速度在记录上有26倍的提升，在重放和分析上有30倍的提升。Jalangi未对数组数据类型进行特殊处理，需要用户自定义。

2017年，Loring等人\cite{expose_2017}借助Jalangi框架，提出了Node.js引擎的动态符号执行工具ExpoSE。ExpoSE能够自动生成测试用例，并有较高到的路径覆盖率。它主要修复了Jalangi对捕获组（capture groups）、反向引用（backreferences）和JavaScript语言正则表达式贪婪匹配的错误处理，并在开源库Minimist中找到了一个之前未被发现的漏洞。

2019年，Loring等人\cite{expose_2019}在ExpoSE的基础上，对其进行了改进，使得它能够处理更多的JavaScript语言特性，能够可靠地对ECMAScript2015标准的test和exec函数进行符号执行。Loring等人使用正则约束来模拟捕获组的语义，并用反例引导的抽象解释精化方法来处理贪婪匹配，效率得到了提高。ExpoSE能够处理整数数据类型，未对数组类型进行特殊处理。

2019年，Amadini等人\cite{aratha}借助Jalangi框架，提出了JavaScript符号执行工具Aratha。通常来说，动态符号执行工具需要使用SMT求解器来求解程序中的约束，但SMT求解器的求解效率瓶颈使得动态符号执行工具的效率受限。Aratha使用约束规划的方法来处理这种情况，该方法会将被分析程序转化为更简单的约束，能够作为动态符号执行工具的互补品，提高工具的效率。Aratha能够处理整数数据类型和数组数据类型，它将数组理论用SMT公式编码，但编码时未考虑字符串函数的语义。

上述JavaScript符号执行工具已经能够初步处理程序中的字符串和整数数据类型，但是对于\textbf{数组}的处理还\textbf{不够完善}。没有充分利用现有的字符串约束求解器，只是用简单的字符串函数去规约实际程序中复杂的字符串函数如$\mysplit$函数和$\myjoin$函数，让字符串求解器损失了一部分信息。

\section{课题主要研究内容、预期目标}
\subsection{研究内容}
本课题的主要研究含整数和数组数据类型的字符串约束求解技术，并将其应用到JavaScript符号执行上。本课题将研究以下两个子课题：
\paragraph{含整数和数组数据类型的字符串约束求解技术}
是子课题JavaScript程序符号执行研究的基础。目前国内外的字符串约束求解器对于整数和数组类型的支持不够完善。同时没有在约束求解层面上考虑会引入数组类型的函数，如$\mysplit$函数和$\myjoin$函数，也没有考虑正则表达式中的捕获组。本课题研究一种更准确的、覆盖整数和数组类型的字符串约束求解技术，在语法上支持$\mysplit$函数、$\myjoin$函数和正则表达式捕获组。探索该约束的可判定性，提取出可判定的字符串约束子集，形成判定算法，开发相应的原型工具。更细致地，本子课题将研究以下三方面内容：
\begin{itemize}
    \item 对含有整数数据类型的字符串约束的研究。
    \item 对带有正则表达式捕获组的$\replaceall$函数的研究。
    \item 对含有数组数据类型的字符串约束研究。
\end{itemize}
（1）对含有整数数据类型的字符串约束的研究：

当字符串含有整数数据类型时，字符串约束会变得更为复杂，比如带有$\replaceall$函数的字符串约束在引入整数数据类型和$\len$函数后，会变得不可判定\cite{repalceall_decidable}。本课题将研究带有整数数据类型的字符串约束的可判定性，并提出一个可判定的子集。该子集中拟支持的函数有：$\replace$函数，$\replaceall$函数， $\transducer$函数， $\reverse$函数， $\concat$函数， $\contain$函数， $\prefix$函数， $\suffix$函数， $\len$函数，$\substr$函数和$\indexof$函数；拟支持的文法约束为正则文法约束；拟支持的数据类型为字符串类型和整数类型，并支持线性整数算术公式的求解。\newline
（2）对带有正则表达式捕获组的$\replaceall$函数的研究：

正则表达式是JavaScript程序中非常常用的语言特性，支持贪婪匹配和非贪婪匹配。贪婪匹配和非贪婪匹配的区别在于，贪婪匹配会尽可能多地匹配字符串，而非贪婪匹配会尽可能少地匹配字符串。在$\replaceall$函数中，贪婪匹配和非贪婪匹配的区别会导致不同的返回结果，这会影响字符串约束的求解结果。同时，正则表达式还支持捕获组，捕获组是正则表达式中用括号括起来的部分，JavaScript程序中的$\replaceall$函数可以在替换串中使用捕获组，这也会影响字符串约束的求解结果。本课题将研究带有正则表达式捕获组的$\replaceall$函数的求解方法，并考虑正则表达式中的贪婪性。探索其可判定性，并提出一个可判定的子集。该子集中拟支持的函数有：带有捕获组的$\replace$函数，带有捕获组的$\replaceall$函数， $\transducer$函数， $\reverse$函数， $\concat$函数， $\contain$函数， $\prefix$函数， $\suffix$函数， $\len$函数，$\substr$函数和$\indexof$函数；拟支持的文法约束为正则文法约束；拟支持的数据类型为字符串类型和整数类型，并支持线性整数算术公式的求解。该部分研究是第一部分研究的扩展，增加了捕获组和正则表达式贪婪性的支持。\newline
（3）对含有数组数据类型的字符串约束研究：

JavaScript程序中的数组类型是一个非常常用的数据类型，但是现有的字符串约束求解器对数组类型的支持不够完善。本课题将研究含有数组数据类型的字符串约束的可判定性，并在已有的字符串函数集基础上，引入$\mysplit$函数和$\myjoin$函数，提出一个可判定的子集。该子集中拟支持的函数有：带有捕获组的$\replace$函数，带有捕获组的$\replaceall$函数， $\transducer$函数， $\reverse$函数， $\concat$函数， $\contain$函数， $\prefix$函数， $\suffix$函数， $\len$函数，$\substr$函数，$\indexof$函数，$\mysplit$函数和$\myjoin$函数；拟支持的文法约束为正则文法约束；拟支持的数据类型为字符串类型、数组类型和整数数据类型，并支持线性整数算术公式的求解。该部分研究是第二部分研究的扩展，增加了对数组数据类型的支持，增加了数组数据类型相关的$\mysplit$函数和$\myjoin$函数。

\paragraph{JavaScript符号执行} 字符串约束求解在程序分析和软件漏洞检测上有着广泛的应用，但是在JavaScript符号执行的应用还不够成熟，现有的分析工具不能很好地对带有整数数据类型、数组数据类型和字符串数据类型的JavaScript程序进行分析，只能部分处理数组数据类型，并未对实际程序中的$\mysplit$函数，$\myjoin$函数和捕获组进行充分考虑，对JavaScript中正则表达式的贪婪性没有很好处理。JavaScript符号执行工具Aratha\cite{aratha}具有较好的可扩展性，已经支持$\concat$、$\indexof$等基本字符串函数的插装。本子课题将对Aratha进行扩展，将带有整数数据类型、数组数据类型和字符串数据类型的路径约束规约到字符串约束上，充分考虑$\mysplit$函数，$\myjoin$函数和捕获组，正确区分正则表达式的贪婪匹配和非贪婪匹配。将含整数和数组数据类型的字符串约束求解技术子课题中开发的字符串约束求解器集成到分析框架中，更准确地刻画整数数据类型、数组类型和字符串类型及相关函数的语义，提高分析效率和正确性。

\subsection{预期目标}
本课题的预期目标为：
\begin{itemize}
    \item 开发能够处理整数和数组数据类型的字符串约束求解器，使其能够支持带有捕获组的$\replace$函数，带有捕获组的$\replaceall$函数， $\transducer$函数， $\reverse$函数， $\concat$函数， $\contain$函数， $\prefix$函数， $\suffix$函数， $\len$函数，$\substr$函数，$\indexof$函数，$\mysplit$函数和$\myjoin$函数，支持正则文法约束，并支持线性整数算术公式的求解。对该约束求解器进行优化，使其和其他主流字符串约束求解器相比，具有更好的性能，能够应用到实际的程序分析工具中。
    \item 扩展已有的JavaScript符号执行框架，使其能够处理带有整数数据类型、数组数据类型和字符串数据类型的JavaScript程序。充分考虑$\mysplit$函数，$\myjoin$函数和捕获组，能够正确区分正则表达式的贪婪匹配和非贪婪匹配。扩展后的JavaScript符号执行引擎能够将带有整数数据类型、数组数据类型和字符串数据类型的程序路径规约到字符串约束上，并将该约束交给上述开发的字符串约束求解器求解。扩展后的JavaScript符号执行引擎需要和其他主流的JavaScript符号执行引擎相比，具有更好的性能或者更好的分析效果。
\end{itemize}

\section{拟采用的研究方法、技术路线、实验方案及其可行性分析}
本节讨论本课题拟采用的研究方法、技术路线、实验方案及其可行性分析。其中研究方法、技术路线、实验方案根据课题的研究内容而定。可行性分析主要从理论上分析课题的可行性。
\subsection{拟采的研究方法、技术路线、实验方案}
根据本课题的研究内容，本课题拟采用的研究方法、技术路线、实验方案有以下两个方面：
\paragraph{含整数和数组数据类型的字符串约束求解技术} 拟采用有限状态自动机及其扩展来对字符串约束进行建模，主要分为以下三个方面：\newline
（1）对含有整数数据类型的字符串约束的求解：

Chen等人在2019年开发了字符串约束求解器OSTRICH\cite{ostrich}，OSTRICH已经能够处理大部分字符串函数，但是还不支持$\len$函数，$\substr$函数和$\indexof$函数这些和整数数据类型相关的函数，拟对OSTRICH进行自动机模型和算法层面的扩展。

首先，需要把OSTRICH的经典有限自动机模型扩展为带有寄存器的有限自动机模型。该自动机模型中每个寄存器对应一个整数变量，它的数值随着自动机中的状态变化而变化。然后，基于OSTRICH中的字符串函数反向传播算法，对$\len$函数，$\substr$函数和$\indexof$函数制定反向传播规则，仔细考虑对应的整数值的变化。每个函数反向传播的结果是一组带寄存器的有限自动机，该自动机记录了该函数中字符串的值和整数的值。当反向传播算法完成后，字符串约束被转化为一组带寄存器的有限自动机，字符串约束求解问题转化为该组自动机的判空问题。

经典自动机的判空问题是可判定的，且有高效的求解算法，但是带寄存器的有限自动机的判空问题还未被研究。它的每个寄存器的取值没有上界，所以本质上是一个无穷状态系统，它的判空问题更为复杂。受到Parikh等人\cite{parikh}将经典自动机转化为线性整数算数公式的启发，拟将带寄存器的有限自动机判空问题转化为线性整数算数公式，将寄存器的值用符号值表示，和输入字符串约束中的其他线性整数算术公式一并交给求解器求解。这个过程中涉及到自动机的求交，会带来状态空间爆炸的问题。拟采用NuXmv工具建模带寄存器的有限自动机组，转化为一个等价的无穷状态迁移系统，用经典的模型检验算法如IC3进行求解，避免求交带来的指数爆炸问题。\newline
（2）对带有正则表达式捕获组的$\replaceall$函数：

Chen等人在2019年的研究\cite{ostrich}中指出，$\replaceall$函数的语义可以用一个字符串转换器（$\transducer$函数来模拟），为了正确处理实际程序中的贪婪匹配和非贪婪匹配，以及处理$\replaceall$函数中的反向引用，需要扩展字符串转换器的表达能力。字符串转换器本质上是一个有穷状态迁移模型，拟在该迁移模型的边上添加优先级，解决贪婪匹配和非贪婪匹配的问题；同时在边上引入字符串变量，记录已经匹配到的字符串及对应的捕获组的值，解决反向引用的问题。最后，定义扩展后的字符串转换器的反向传播规则，使其能够应用OSTRICH的反向传播算法。\newline
（3）对含有数组数据类型的字符串约束：

拟将字符串数组看作一个长的字符串，该字符串用特殊的符号$\sharp$来分隔数组中的元素。如一个含三个字符串元素的数组$[‘a’,‘b’,‘c’]$，用字符串$‘a\sharp b\sharp c’$来表示它。这样，就能够用扩展后的有限状态自动机来刻画数组类型的变量，用寄存器来存储数组的下标。对于一般的数组，拟采用SMT求解器中经典的数组理论，用已有的算法求解。$\myjoin$函数输入一个字符串数组和一个连接符，返回一个连接后的字符串。拟复用OSTRICH中的反向传播算法，定义$\myjoin$的反向传播规则。需要注意到是，由于字符串数组可以用带寄存器的有限自动机来建模，$\myjoin$函数的反向传播返回一个带寄存器的有限自动机表示数组。$\mysplit$函数输入一个字符串和一个分割符，返回一个分割后的子串数组。注意不同于$\myjoin$函数，$\mysplit$函数的输出是一个数组，这个数组可能是一个变量，所以没有直接对应的带寄存器的有限自动机模型。需要分析上下文信息，探测数组中的具体字符串元素，生成对应模型，然后再定义$\mysplit$的反向传播规则。
\paragraph{JavaScript符号执行：} 本课题拟采用上述字符串约束求解器，对已有JavaScript符号执行引擎进行扩展，定义数组相关字符串函数如$\mysplit$和$\myjoin$的插装，定义带有捕获组的字符串函数如$\test$、$\match$和$\replaceall$的插装，使其能正确生成相应的字符串约束。其他字符串函数的定义则不变。引入数组类型后，求解速度可能变慢，带有寄存器的自动机组的可达性带来的路径爆炸的问题不可忽视。首先，本课题将根据已有经验，探索高效的启发式求解算法，用NuXmv工具进行启发式求解，将自动机下近似地地转化为线性整数算术公式。其次，本课题拟将Concolic执行方法应用到该分析框架中。Concolic执行遇到某些复杂的字符串函数调用时，只对被调用函数做具体执行，不进入被调用的函数，而是在函数返回后，以其输出作为新的符号变量加入到符号状态，并继续运行程序。本次执行结束后，回到调用点，根据执行的结果搜索被调用函数的路径空间，利用本次执行已获得的信息只搜集所需部分的路径约束从而避免了枚举所有路径，达到节省计算的目的。

\subsection{可行性分析}
近年来字符串约束求解技术及其应用已经被系统地进行研究，以上的理论分析已经过大量调研并产生了一定的理论成果。本人导师在自动机理论、字符串约束求解方面有着丰富的研究经验，其团队和国外团队共同开发了字符串约束求解器OSTRICH，是第一个能够支持$\replaceall$函数的字符串约束求解器。本课题的字符串约束求解工具可以在OSTRICH的基础上进行扩展；同时本人所在团队和国外团队共同扩展了JavaScript符号执行工具Aratha，使其能够支持贪婪匹配和$\replaceall$的反向引用，扩展后的Aratha效率高于ExpoSE。本课题的符号执行工具可以在Aratha的基础上进行扩展，因此本课题的研究目标是可行的。

\section{已有科研基础与所需的科研条件}
本人与导师合作发表了三篇文章:
\begin{itemize}
    \item  T. Chen, M. Hague, J. He, D. Hu, A. Lin, P. Ruemmer, Z. Wu: A Decision Procedure for Path Feasibility of String Manipulating Programs with Integer Data Type. ATVA 2020.\cite{ostrich_atva}该文章研究了带有整数类型的字符串约束求解问题，被ATVA2020录用。
    \item P. Abdulla, M. Atig, Y. Chen, B. Diep, L. Holík, D. Hu, W. Tsai, Z. Wu, D. Yen: Solving Not-Substring Constraint with Flat Abstraction. APLAS 2021.\cite{not_substr}该文章研究了带有$\mathsf{not-substring}$约束的字符串约束求解问题，被APLAS2021录用。
    \item  T. Chen, M. Hague, Z. Han, D. Hu, A. Lamas, A. Lin, S. Kan, P. Ruemmer, Z. Wu: Solving String Constraints With Regex-Dependent Functions Through Transducers With Priorities And Variables. POPL2022.\cite{ostrich_greedy}该文章研究了带有贪婪匹配正则表达式的的函数如$\test$函数，研究了带有反向引用的$\replaceall$函数的建模和求解，被POPL2022录用。
\end{itemize}

\section{研究工作计划与进度安排}
\begin{itemize}
    \item 2023年8月至2023年12月：研究带有寄存器的有限自动机的可达性问题的高效求解方法，设计并实现启发式算法。
    \item 2024年1月至2024年6月：研究带有数组类型的字符串约束的可判定性，设计求解算法并开发相应字符串约束求解器。  
    \item 2024年7月至2025年2月：扩展JavaScipt符号执行引擎，将能够处理数组类型字符串约束求解器集成到符号执行引擎中。
\end{itemize}


\nocite{*}% 使文献列表显示所有参考文献（包括未引用文献）
%---------------------------------------------------------------------------%
