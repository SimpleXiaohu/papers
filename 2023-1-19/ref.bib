
% Journals

% First the Full Name is given, then the abbreviation used in the AMS Math
% Reviews, with an indication if it could not be found there.
% Note the 2nd overwrites the 1st, so swap them if you want the full name.


%Entries

@InProceedings{atva2020,
author="Chen, Taolue
and Hague, Matthew
and He, Jinlong
and Hu, Denghang
and Lin, Anthony Widjaja
and R{\"u}mmer, Philipp
and Wu, Zhilin",
editor="Hung, Dang Van
and Sokolsky, Oleg",
title="A Decision Procedure for Path Feasibility of String Manipulating Programs with Integer Data Type",
booktitle="Automated Technology for Verification and Analysis",
year="2020",
publisher="Springer International Publishing",
address="Cham",
pages="325--342"
},

@article{parikh_theorem,
author = {Parikh, Rohit J.},
title = {On Context-Free Languages},
year = {1966},
issue_date = {Oct. 1966},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {13},
number = {4},
issn = {0004-5411},
url = {https://doi.org/10.1145/321356.321364},
doi = {10.1145/321356.321364},
abstract = {In this report, certain properties of context-free (CF or type 2) grammars are investigated, like that of Chomsky. In particular, questions regarding structure, possible ambiguity and relationship to finite automata are considered. The following results are presented: The language generated by a context-free grammmar is linear in a sense that is defined precisely.The requirement of unambiguity—that every sentence has a unique phrase structure—weakens the grammar in the sense that there exists a CF language that cannot be generated unambiguously by a CF grammar.The result that not every CF language is a finite automaton (FA) language is improved in the following way. There exists a CF language L such that for any L′ ⊆ L, if L′ is FA, an L″ ⊆ L can be found such that L″ is also FA, L′ ⊆ L″ and L″ contains infinitely many sentences not in L′.A type of grammar is defined that is intermediate between type 1 and type 2 grammars. It is shown that this type of grammar is essentially stronger than type 2 grammars and has the advantage over type 1 grammars that the phrase structure of a grammatical sentence is unique, once the derivation is given.},
journal = {J. ACM},
month = {oct},
pages = {570–581},
numpages = {12}
}

@inproceedings{parikh_compute,
author = {Verma, Kumar Neeraj and Seidl, Helmut and Schwentick, Thomas},
title = {On the Complexity of Equational Horn Clauses},
year = {2005},
isbn = {3540280057},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/11532231_25},
doi = {10.1007/11532231_25},
abstract = {Security protocols employing cryptographic primitives with algebraic properties are conveniently modeled using Horn clauses modulo equational theories. We consider clauses corresponding to the class $mathcal{H}3$ of Nielson, Nielson and Seidl. We show that modulo the theory ACU of an associative-commutative symbol with unit, as well as its variants like the theory XOR and the theory AG of Abelian groups, unsatisfiability is NP-complete. Also membership and intersection-non-emptiness problems for the closely related class of one-way as well as two-way tree automata modulo these equational theories are NP-complete. A key technical tool is a linear time construction of an existential Presburger formula corresponding to the Parikh image of a context-free language. Our algorithms require deterministic polynomial time using an oracle for existential Presburger formulas, suggesting efficient implementations are possible.},
booktitle = {Proceedings of the 20th International Conference on Automated Deduction},
pages = {337–352},
numpages = {16},
location = {Tallinn, Estonia},
series = {CADE' 20}
}

@online{parikh_for_nfa,
  author = {Peter Habermehl},
  title = {The Parikh image of languages and linear constraints},
  year = 2012,
  url = {http://www.it.uu.se/research/group/astra/CPmeetsCAV/slides/habermehl.pdf},
  urldate = {2012-6-28}
}

@article{parikh_anthony,
  author    = {Anthony Widjaja To},
  title     = {Parikh Images of Regular Languages: Complexity and Applications},
  journal   = {CoRR},
  volume    = {abs/1002.1464},
  year      = {2010},
  url       = {http://arxiv.org/abs/1002.1464},
  eprinttype = {arXiv},
  eprint    = {1002.1464},
  timestamp = {Mon, 13 Aug 2018 16:46:30 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-1002-1464.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{redos_fse2019,
author = {Davis, James C.},
title = {Rethinking Regex Engines to Address ReDoS},
year = {2019},
isbn = {9781450355728},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3338906.3342509},
doi = {10.1145/3338906.3342509},
abstract = {Regular expressions (regexes) are a powerful string manipulation tool. Unfortunately, in programming languages like Python, Java, and JavaScript, they are unnecessarily dangerous, implemented with worst-case exponential matching behavior. This high time complexity exposes software services to regular expression denial of service (ReDoS) attacks. We propose a data-driven redesign of regex engines, to reflect how regexes are used and what they typically look like. We report that about 95% of regexes in popular programming languages can be evaluated in linear time. The regex engine is a fundamental component of a programming language, and any changes risk introducing compatibility problems. We believe a full redesign is therefore impractical, and so we describe how the vast majority of regex matches can be made linear-time with minor, not major, changes to existing algorithms. Our prototype shows that on a kernel of the regex language, we can trade space for time to make regex matches safe},
booktitle = {Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
pages = {1256–1258},
numpages = {3},
keywords = {REDOS, catastrophic backtracking, Regular expressions, empirical software engineering},
location = {Tallinn, Estonia},
series = {ESEC/FSE 2019}
}

@inproceedings{symbolic_pldi2021,
author = {Stanford, Caleb and Veanes, Margus and Bj\o{}rner, Nikolaj},
title = {Symbolic Boolean Derivatives for Efficiently Solving Extended Regular Expression Constraints},
year = {2021},
isbn = {9781450383912},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3453483.3454066},
doi = {10.1145/3453483.3454066},
booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {620–635},
numpages = {16},
keywords = {SMT, automaton, derivative, regex, regular expression, string},
location = {Virtual, Canada},
series = {PLDI 2021}
},

@article{undecidable_1,
author = {Ganesh, Vijay and Berzish, Murphy},
year = {2016},
month = {05},
pages = {},
title = {Undecidability of a Theory of Strings, Linear Arithmetic over Length, and String-Number Conversion}
}

@InProceedings{undecidable_2,
author="Ganesh, Vijay
and Minnes, Mia
and Solar-Lezama, Armando
and Rinard, Martin",
editor="Biere, Armin
and Nahir, Amir
and Vos, Tanja",
title="Word Equations with Length Constraints: What's Decidable?",
booktitle="Hardware and Software: Verification and Testing",
year="2013",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="209--226",
abstract="We prove several decidability and undecidability results for the satisfiability and validity problems for languages that can express solutions to word equations with length constraints. The atomic formulas over this language are equality over string terms (word equations), linear inequality over the length function (length constraints), and membership in regular sets. These questions are important in logic, program analysis, and formal verification. Variants of these questions have been studied for many decades by mathematicians. More recently, practical satisfiability procedures (aka SMT solvers) for these formulas have become increasingly important in the context of security analysis for string-manipulating programs such as web applications.",
isbn="978-3-642-39611-3"
}



@book{aut_hopcraft,
  added-at = {2009-05-20T01:29:36.000+0200},
  author = {Hopcroft, John E. and Ullman, Jeff D.},
  biburl = {https://www.bibsonomy.org/bibtex/26f42b10773b0f97be73d4e0d6b8db3bf/sriram0339},
  description = {First cut database},
  interhash = {0fb20598f4921085d9c5058fc8d95f00},
  intrahash = {6f42b10773b0f97be73d4e0d6b8db3bf},
  keywords = {imported},
  publisher = {Addison-Wesley Publishing Company},
  timestamp = {2009-05-20T01:29:37.000+0200},
  title = {Introduction to Automata Theory, Languages, and Computation},
  year = 1979
},

@InProceedings{quadratic_aplas2018,
author="Le, Quang Loc
and He, Mengda",
editor="Ryu, Sukyoung",
title="A Decision Procedure for String Logic with Quadratic Equations, Regular Expressions and Length Constraints",
booktitle="Programming Languages and Systems",
year="2018",
publisher="Springer International Publishing",
address="Cham",
pages="350--372",
isbn="978-3-030-02768-1"
},

@misc{ostrich2023,
  author = {Denghang Hu},
  title = {ostich},
  year = {2023},
  publisher = {GitHub},
  journal = {GitHub repository},
  howpublished = {\url{https://github.com/SimpleXiaohu/ostrich/tree/cost-enriched-automata}},
  commit = {ea01ed126fdb7f96c6f8ad6474487df2b6a98aab}
},
@MISC{stackoverflow,
title = {Stackoverflow},
month = may,
year = {2022},
howpublished={\url{https://stackoverflow.com/}}
},

@MISC{regexlib,
title = {regular expression library},
month = may,
year = {2022},
howpublished={\url{https://regexlib.com/}}
},

@article{zaligvinder_2021,
author = {Kulczynski, Mitja and Manea, Florin and Nowotka, Dirk and Poulsen, Danny Bøgsted},
title = {ZaligVinder: A generic test framework for string solvers},
journal = {Journal of Software: Evolution and Process},
volume = {35},
number = {4},
pages = {e2400},
keywords = {analysis of string solvers, string solving benchmarks, test framework for string solvers},
doi = {https://doi.org/10.1002/smr.2400},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/smr.2400},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/smr.2400},
abstract = {Abstract The increased interest in string solving in the recent years has made it very hard to identify the right tool to address a particular user's purpose. Firstly, there is a multitude of string solvers, each addressing essentially some subset of the general problem. Generally, the addressed fragments are relevant and well motivated, but the lack of comparisons between the existing tools on an equal set of benchmarks cannot go unnoticed, especially as a common framework to compare solvers seems to be missing. In this paper, we gather a set of relevant benchmarks and introduce our new benchmarking framework to address this purpose.},
year = {2023}
}


@InProceedings{unary_nfa_2010,
author="Sawa, Zden{\v{e}}k",
editor="Ku{\v{c}}era, Anton{\'i}n
and Potapov, Igor",
title="Efficient Construction of Semilinear Representations of Languages Accepted by Unary NFA",
booktitle="Reachability Problems",
year="2010",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="176--182",
abstract="Chrobak (1986) proved that a language accepted by a given nondeterministic finite automaton with one-letter alphabet, i.e., a unary NFA, with n states can be represented as the union of O(n2) arithmetic progressions, and Martinez (2002) has shown how to compute these progressions in polynomial time. To (2009) has pointed out recently that Chrobak's construction and Martinez's algorithm, which is based on it, contain a subtle error and has shown how they can be corrected. In this paper, a new simpler and more efficient algorithm for the same problem is presented. The running time of the presented algorithm is O(n2(n{\thinspace}+{\thinspace}m)), where n is the number of states and m the number of transitions of a given unary NFA.",
isbn="978-3-642-15349-5"
}

@InProceedings{bmc_1,
author="Biere, Armin
and Cimatti, Alessandro
and Clarke, Edmund
and Zhu, Yunshan",
editor="Cleaveland, W. Rance",
title="Symbolic Model Checking without BDDs",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="1999",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="193--207",
abstract="Symbolic Model Checking [3], [14] has proven to be a powerful technique for the verification of reactive systems. BDDs [2] have traditionally been used as a symbolic representation of the system. In this paper we show how boolean decision procedures, like St{\aa}lmarck's Method [16] or the Davis {\&} Putnam Procedure [7], can replace BDDs. This new technique avoids the space blow up of BDDs, generates counterexamples much faster, and sometimes speeds up the verification. In addition, it produces counterexamples of minimal length. We introduce a bounded model checking procedure for LTL which reduces model checking to propositional satisfiability.We show that bounded LTL model checking can be done without a tableau construction. We have implemented a model checker BMC, based on bounded model checking, and preliminary results are presented.",
isbn="978-3-540-49059-3"
}

@article{bmc_2,
  title={Bounded model checking using satisfiability solving},
  author={Clarke, Edmund and Biere, Armin and Raimi, Richard and Zhu, Yunshan},
  journal={Formal methods in system design},
  volume={19},
  pages={7--34},
  year={2001},
  publisher={Springer}
}

@article{bmc_3,
  title={Bounded model checking},
  author={Armin Biere},
  journal={Adv. Comput.},
  year={2021},
  volume={58},
  pages={117-148}
}

@InProceedings{nuxmv,
author="Cavada, Roberto
and Cimatti, Alessandro
and Dorigatti, Michele
and Griggio, Alberto
and Mariotti, Alessandro
and Micheli, Andrea
and Mover, Sergio
and Roveri, Marco
and Tonetta, Stefano",
editor="Biere, Armin
and Bloem, Roderick",
title="The nuXmv Symbolic Model Checker",
booktitle="Computer Aided Verification",
year="2014",
publisher="Springer International Publishing",
address="Cham",
pages="334--342",
abstract="This paper describes the nuXmv symbolic model checker for finite- and infinite-state synchronous transition systems. nuXmv is the evolution of the nuXmv open source model checker. It builds on and extends nuXmv along two main directions. For finite-state systems it complements the basic verification techniques of nuXmv with state-of-the-art verification algorithms. For infinite-state systems, it extends the nuXmv language with new data types, namely Integers and Reals, and it provides advanced SMT-based model checking techniques.",
isbn="978-3-319-08867-9"
}

@InProceedings{princess,
author="R{\"u}mmer, Philipp",
editor="Cervesato, Iliano
and Veith, Helmut
and Voronkov, Andrei",
title="A Constraint Sequent Calculus for First-Order Logic with Linear Integer Arithmetic",
booktitle="Logic for Programming, Artificial Intelligence, and Reasoning",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="274--289",
abstract="First-order logic modulo the theory of integer arithmetic is the basis for reasoning in many areas, including deductive software verification and software model checking. While satisfiability checking for ground formulae in this logic is well understood, it is still an open question how the general case of quantified formulae can be handled in an efficient and systematic way. As a possible answer, we introduce a sequent calculus that combines ideas from free-variable constraint tableaux with the Omega quantifier elimination procedure. The calculus is complete for theorems of first-order logic (without functions, but with arbitrary uninterpreted predicates), can decide Presburger arithmetic, and is complete for a substantial fragment of the combination of both.",
isbn="978-3-540-89439-1"
}

@InProceedings{z3,
author="de Moura, Leonardo
and Bj{\o}rner, Nikolaj",
editor="Ramakrishnan, C. R.
and Rehof, Jakob",
title="Z3: An Efficient SMT Solver",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="337--340",
abstract="Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first order formulas with respect to combinations of background theories such as: arithmetic, bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver freely available from Microsoft Research. It is used in various software verification and analysis applications.",
isbn="978-3-540-78800-3"
}

@inproceedings{z3str3,
author = {Berzish, Murphy and Ganesh, Vijay and Zheng, Yunhui},
title = {Z3str3: A String Solver with Theory-Aware Heuristics},
year = {2017},
isbn = {9780983567875},
publisher = {FMCAD Inc},
address = {Austin, Texas},
abstract = {We present a new string SMT solver, Z3str3, that is faster than its competitors Z3str2, Norn, CVC4, S3, and S3P over a majority of three industrial-strength benchmarks, namely, Kaluza, PISA, and IBM AppScan. Z3str3 supports string equations, linear arithmetic over length function, and regular language membership predicate. The key algorithmic innovation behind the efficiency of Z3str3 is a technique we call theory-aware branching, wherein we modify Z3's branching heuristic to take into account the structure of theory literals to compute branching activities. In the traditional DPLL(T) architecture, the structure of theory literals is hidden from the DPLL(T) SAT solver because of the Boolean abstraction constructed over the input theory formula. By contrast, the theory-aware technique presented in this paper exposes the structure of theory literals to the DPLL(T) SAT solver's branching heuristic, thus enabling it to make much smarter decisions during its search than otherwise. As a consequence, Z3str3 has better performance than its competitors.},
booktitle = {Proceedings of the 17th Conference on Formal Methods in Computer-Aided Design},
pages = {55–59},
numpages = {5},
location = {Vienna, Austria},
series = {FMCAD '17}
}

@inproceedings{z3seq,
author = {Stanford, Caleb and Veanes, Margus and Bj\o{}rner, Nikolaj},
title = {Symbolic Boolean Derivatives for Efficiently Solving Extended Regular Expression Constraints},
year = {2021},
isbn = {9781450383912},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3453483.3454066},
doi = {10.1145/3453483.3454066},
abstract = {The manipulation of raw string data is ubiquitous in security-critical software, and verification of such software relies on efficiently solving string and regular expression constraints via SMT. However, the typical case of Boolean combinations of regular expression constraints exposes blowup in existing techniques. To address solvability of such constraints, we propose a new theory of derivatives of symbolic extended regular expressions (extended meaning that complement and intersection are incorporated), and show how to apply this theory to obtain more efficient decision procedures. Our implementation of these ideas, built on top of Z3, matches or outperforms state-of-the-art solvers on standard and handwritten benchmarks, showing particular benefits on examples with Boolean combinations. Our work is the first formalization of derivatives of regular expressions which both handles intersection and complement and works symbolically over an arbitrary character theory. It unifies existing approaches involving derivatives of extended regular expressions, alternating automata and Boolean automata by lifting them to a common symbolic platform. It relies on a parsimonious augmentation of regular expressions: a construct for symbolic conditionals is shown to be sufficient to obtain relevant closure properties for derivatives over extended regular expressions.},
booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {620–635},
numpages = {16},
keywords = {automaton, derivative, regex, regular expression, SMT, string},
location = {Virtual, Canada},
series = {PLDI 2021}
}

@InProceedings{z3str3re,
author="Berzish, Murphy
and Kulczynski, Mitja
and Mora, Federico
and Manea, Florin
and Day, Joel D.
and Nowotka, Dirk
and Ganesh, Vijay",
editor="Silva, Alexandra
and Leino, K. Rustan M.",
title="An SMT Solver for Regular Expressions and Linear Arithmetic over String Length",
booktitle="Computer Aided Verification",
year="2021",
publisher="Springer International Publishing",
address="Cham",
pages="289--312",
abstract="We present a novel length-aware solving algorithm for the quantifier-free first-order theory over regex membership predicate and linear arithmetic over string length. We implement and evaluate this algorithm and related heuristics in the Z3 theorem prover. A crucial insight that underpins our algorithm is that real-world regex and string formulas contain a wealth of information about upper and lower bounds on lengths of strings, and such information can be used very effectively to simplify operations on automata representing regular expressions. Additionally, we present a number of novel general heuristics, such as the prefix/suffix method, that can be used to make a variety of regex solving algorithms more efficient in practice. We showcase the power of our algorithm and heuristics via an extensive empirical evaluation over a large and diverse benchmark of 57256 regex-heavy instances, almost 75{\%} of which are derived from industrial applications or contributed by other solver developers. Our solver outperforms five other state-of-the-art string solvers, namely, CVC4, OSTRICH, Z3seq, Z3str3, and Z3-Trau, over this benchmark, in particular achieving a speedup of 2.4{\$}{\$}{\backslash}times {\$}{\$}{\texttimes}over CVC4, 4.4{\$}{\$}{\backslash}times {\$}{\$}{\texttimes}over Z3seq, 6.4{\$}{\$}{\backslash}times {\$}{\$}{\texttimes}over Z3-Trau, 9.1{\$}{\$}{\backslash}times {\$}{\$}{\texttimes}over Z3str3, and 13{\$}{\$}{\backslash}times {\$}{\$}{\texttimes}over OSTRICH.",
isbn="978-3-030-81688-9"
}

@InProceedings{cvc5,
author="Barbosa, Haniel
and Barrett, Clark
and Brain, Martin
and Kremer, Gereon
and Lachnitt, Hanna
and Mann, Makai
and Mohamed, Abdalrhman
and Mohamed, Mudathir
and Niemetz, Aina
and N{\"o}tzli, Andres
and Ozdemir, Alex
and Preiner, Mathias
and Reynolds, Andrew
and Sheng, Ying
and Tinelli, Cesare
and Zohar, Yoni",
editor="Fisman, Dana
and Rosu, Grigore",
title="cvc5: A Versatile and Industrial-Strength SMT Solver",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2022",
publisher="Springer International Publishing",
address="Cham",
pages="415--442",
abstract="cvc5 is the latest SMT solver in the cooperating validity checker series and builds on the successful code base of CVC4. This paper serves as a comprehensive system description of cvc5 's architectural design and highlights the major features and components introduced since CVC4  1.8. We evaluate cvc5 's performance on all benchmarks in SMT-LIB and provide a comparison against CVC4 and Z3.",
isbn="978-3-030-99524-9"
}

@INPROCEEDINGS{trau,
  author={Abdulla, Parosh Aziz and Faouzi Atig, Mohamed and Chen, Yu-Fang and Diep, Bui Phi and Holík, Lukáš and Rezine, Ahmed and Rümmer, Philipp},
  booktitle={2018 Formal Methods in Computer Aided Design (FMCAD)}, 
  title={Trau: SMT solver for string constraints}, 
  year={2018},
  volume={},
  number={},
  pages={1-5},
  doi={10.23919/FMCAD.2018.8602997}
}

@inproceedings{z3trau,
author = {Abdulla, Parosh Aziz and Atig, Mohamed Faouzi and Chen, Yu-Fang and Diep, Bui Phi and Dolby, Julian and Jank\r{u}, Petr and Lin, Hsin-Hung and Hol\'{\i}k, Luk\'{a}\v{s} and Wu, Wei-Cheng},
title = {Efficient Handling of String-Number Conversion},
year = {2020},
isbn = {9781450376136},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3385412.3386034},
doi = {10.1145/3385412.3386034},
abstract = {String-number conversion is an important class of constraints needed for the symbolic execution of string-manipulating programs. In particular solving string constraints with string-number conversion is necessary for the analysis of scripting languages such as JavaScript and Python, where string-number conversion is a part of the definition of the core semantics of these languages. However, solving this type of constraint is very challenging for the state-of-the-art solvers. We propose in this paper an approach that can efficiently support both string-number conversion and other common types of string constraints. Experimental results show that it significantly outperforms other state-of-the-art tools on benchmarks that involves string-number conversion.},
booktitle = {Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {943–957},
numpages = {15},
keywords = {Formal Verification, String Solver, Automata},
location = {London, UK},
series = {PLDI 2020}
}

@article{ostrich,
author = {Chen, Taolue and Hague, Matthew and Lin, Anthony W. and R\"{u}mmer, Philipp and Wu, Zhilin},
title = {Decision Procedures for Path Feasibility of String-Manipulating Programs with Complex Operations},
year = {2019},
issue_date = {January 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {POPL},
url = {https://doi.org/10.1145/3290362},
doi = {10.1145/3290362},
abstract = {The design and implementation of decision procedures for checking path feasibility in string-manipulating programs is an important problem, with such applications as symbolic execution of programs with strings and automated detection of cross-site scripting (XSS) vulnerabilities in web applications. A (symbolic) path is given as a finite sequence of assignments and assertions (i.e. without loops), and checking its feasibility amounts to determining the existence of inputs that yield a successful execution. Modern programming languages (e.g. JavaScript, PHP, and Python) support many complex string operations, and strings are also often implicitly modified during a computation in some intricate fashion (e.g. by some autoescaping mechanisms). In this paper we provide two general semantic conditions which together ensure the decidability of path feasibility: (1) each assertion admits regular monadic decomposition (i.e. is an effectively recognisable relation), and (2) each assignment uses a (possibly nondeterministic) function whose inverse relation preserves regularity. We show that the semantic conditions are expressive since they are satisfied by a multitude of string operations including concatenation, one-way and two-way finite-state transducers, replaceall functions (where the replacement string could contain variables), string-reverse functions, regular-expression matching, and some (restricted) forms of letter-counting/length functions. The semantic conditions also strictly subsume existing decidable string theories (e.g. straight-line fragments, and acyclic logics), and most existing benchmarks (e.g. most of Kaluza’s, and all of SLOG’s, Stranger’s, and SLOTH’s benchmarks). Our semantic conditions also yield a conceptually simple decision procedure, as well as an extensible architecture of a string solver in that a user may easily incorporate his/her own string functions into the solver by simply providing code for the pre-image computation without worrying about other parts of the solver. Despite these, the semantic conditions are unfortunately too general to provide a fast and complete decision procedure. We provide strong theoretical evidence for this in the form of complexity results. To rectify this problem, we propose two solutions. Our main solution is to allow only partial string functions (i.e., prohibit nondeterminism) in condition (2). This restriction is satisfied in many cases in practice, and yields decision procedures that are effective in both theory and practice. Whenever nondeterministic functions are still needed (e.g. the string function split), our second solution is to provide a syntactic fragment that provides a support of nondeterministic functions, and operations like one-way transducers, replaceall (with constant replacement string), the string-reverse function, concatenation, and regular-expression matching. We show that this fragment can be reduced to an existing solver SLOTH that exploits fast model checking algorithms like IC3. We provide an efficient implementation of our decision procedure (assuming our first solution above, i.e., deterministic partial string functions) in a new string solver OSTRICH. Our implementation provides built-in support for concatenation, reverse, functional transducers (FFT), and replaceall and provides a framework for extensibility to support further string functions. We demonstrate the efficacy of our new solver against other competitive solvers.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {49},
numpages = {30},
keywords = {Reverse, Decision Procedures, Transducers, ReplaceAll, Straight-Line Programs, String Constraints}
}

@inproceedings{s3,
author = {Trinh, Minh-Thai and Chu, Duc-Hiep and Jaffar, Joxan},
title = {S3: A Symbolic String Solver for Vulnerability Detection in Web Applications},
year = {2014},
isbn = {9781450329576},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2660267.2660372},
doi = {10.1145/2660267.2660372},
abstract = {Motivated by the vulnerability analysis of web programs which work on string inputs, we present S3, a new symbolic string solver. Our solver employs a new algorithm for a constraint language that is expressive enough for widespread applicability. Specifically, our language covers all the main string operations, such as those in JavaScript. The algorithm first makes use of a symbolic representation so that membership in a set defined by a regular expression can be encoded as string equations. Secondly, there is a constraint-based generation of instances from these symbolic expressions so that the total number of instances can be limited. We evaluate S3 on a well-known set of practical benchmarks, demonstrating both its robustness (more definitive answers) and its efficiency (about 20 times faster) against the state-of-the-art.},
booktitle = {Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security},
pages = {1232–1243},
numpages = {12},
keywords = {string constraint solver, string analysis, web applications},
location = {Scottsdale, Arizona, USA},
series = {CCS '14}
}

@article{sloth,
author = {Hol\'{\i}k, Luk\'{a}\v{s} and Jank\r{u}, Petr and Lin, Anthony W. and R\"{u}mmer, Philipp and Vojnar, Tom\'{a}\v{s}},
title = {String Constraints with Concatenation and Transducers Solved Efficiently},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {POPL},
url = {https://doi.org/10.1145/3158092},
doi = {10.1145/3158092},
abstract = {String analysis is the problem of reasoning about how strings are manipulated by a program. It has numerous applications including automatic detection of cross-site scripting, and automatic test-case generation. A&nbsp;popular string analysis technique includes symbolic executions, which at their core use constraint solvers over the string domain, a.k.a. string solvers. Such solvers typically reason about constraints expressed in theories over strings with the concatenation operator as an atomic constraint. In recent years, researchers started to recognise the importance of incorporating the replace-all operator (i.e. replace all occurrences of a string by another string) and, more generally, finite-state transductions in the theories of strings with concatenation. Such string operations are typically crucial for reasoning about XSS vulnerabilities in web applications, especially for modelling sanitisation functions and implicit browser transductions (e.g. innerHTML). Although this results in an undecidable theory in general, it was recently shown that the straight-line fragment of the theory is decidable, and is sufficiently expressive in practice. In this paper, we provide the first string solver that can reason about constraints involving both concatenation and finite-state transductions. Moreover, it has a completeness and termination guarantee for several important fragments (e.g. straight-line fragment). The main challenge addressed in the paper is the prohibitive worst-case complexity of the theory (double-exponential time), which is exponentially harder than the case without finite-state transductions. To this end, we propose a method that exploits succinct alternating finite-state automata as concise symbolic representations of string constraints. In contrast to previous approaches using nondeterministic automata, alternation offers not only exponential savings in space when representing Boolean combinations of transducers, but also a possibility of succinct representation of otherwise costly combinations of transducers and concatenation. Reasoning about the emptiness of the AFA language requires a state-space exploration in an exponential-sized graph, for which we use model checking algorithms (e.g.&nbsp;IC3). We have implemented our algorithm and demonstrated its efficacy on benchmarks that are derived from cross-site scripting analysis and other examples in the literature.},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {4},
numpages = {32},
keywords = {Decision Procedure, String Solving, IC3, Alternating Finite Automata}
}

@InProceedings{abc,
author="Aydin, Abdulbaki
and Bang, Lucas
and Bultan, Tevfik",
editor="Kroening, Daniel
and P{\u{a}}s{\u{a}}reanu, Corina S.",
title="Automata-Based Model Counting for String Constraints",
booktitle="Computer Aided Verification",
year="2015",
publisher="Springer International Publishing",
address="Cham",
pages="255--272",
abstract="Most common vulnerabilities in Web applications are due to string manipulation errors in input validation and sanitization code. String constraint solvers are essential components of program analysis techniques for detecting and repairing vulnerabilities that are due to string manipulation errors. For quantitative and probabilistic program analyses, checking the satisfiability of a constraint is not sufficient, and it is necessary to count the number of solutions. In this paper, we present a constraint solver that, given a string constraint, (1) constructs an automaton that accepts all solutions that satisfy the constraint, (2) generates a function that, given a length bound, gives the total number of solutions within that bound. Our approach relies on the observation that, using an automata-based constraint representation, model counting reduces to path counting, which can be solved precisely. We demonstrate the effectiveness of our approach on a large set of string constraints extracted from real-world web applications.",
isbn="978-3-319-21690-4"
}

@InProceedings{dpll_t,
author="Ganzinger, Harald
and Hagen, George
and Nieuwenhuis, Robert
and Oliveras, Albert
and Tinelli, Cesare",
editor="Alur, Rajeev
and Peled, Doron A.",
title="DPLL(T): Fast Decision Procedures",
booktitle="Computer Aided Verification",
year="2004",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="175--188",
abstract="The logic of equality with uninterpreted functions (EUF) and its extensions have been widely applied to processor verification, by means of a large variety of progressively more sophisticated (lazy or eager) translations into propositional SAT. Here we propose a new approach, namely a general DPLL(X) engine, whose parameter X can be instantiated with a specialized solver SolverTfor a given theory T, thus producing a system DPLL(T). We describe this DPLL(T) scheme, the interface between DPLL(X) and SolverT, the architecture of DPLL(X), and our solver for EUF, which includes incremental and backtrackable congruence closure algorithms for dealing with the built-in equality and the integer successor and predecessor symbols. Experiments with a first implementation indicate that our technique already outperforms the previous methods on most benchmarks, and scales up very well.",
isbn="978-3-540-27813-9"
}

@article{redos_lenka,
author = "Turo\v{n}ov\'{a}, Lenka 
and Hol\'{\i}k, Luk\'{a}\v{s} 
and Leng\'{a}l, Ond\v{r}ej 
and Saarikivi, Olli 
and Veanes, Margus 
and Vojnar, Tom\'{a}\v{s}",
title = {Regex Matching with Counting-Set Automata},
year = {2020},
issue_date = {November 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {OOPSLA},
url = {https://doi.org/10.1145/3428286},
doi = {10.1145/3428286},
abstract = {We propose a solution to the problem of efficient matching regular expressions (regexes) with bounded repetition, such as (ab){1,100}, using deterministic automata. For this, we introduce novel counting-set automata (CsAs), automata with registers that can hold sets of bounded integers and can be manipulated by a limited portfolio of constant-time operations. We present an algorithm that compiles a large sub-class of regexes to deterministic CsAs. This includes (1) a novel Antimirov-style translation of regexes with counting to counting automata (CAs), nondeterministic automata with bounded counters, and (2) our main technical contribution, a determinization of CAs that outputs CsAs. The main advantage of this workflow is that the size of the produced CsAs does not depend on the repetition bounds used in the regex (while the size of the DFA is exponential to them). Our experimental results confirm that deterministic CsAs produced from practical regexes with repetition are indeed vastly smaller than the corresponding DFAs. More importantly, our prototype matcher based on CsA simulation handles practical regexes with repetition regardless of sizes of counter bounds. It easily copes with regexes with repetition where state-of-the-art matchers struggle.},
journal = {Proc. ACM Program. Lang.},
month = {nov},
articleno = {218},
numpages = {30},
keywords = {regular expression matching, determinization, counting-set automata, counting automata, bounded repetition, ReDos, Antimirov's derivatives}
}

@misc{smt_lib,
  author = "Cesare, Tinelli
and Clark, Barrett
and Pascal, Fontaine",
  title = {SMT-LIB: The Satisfiability Modulo Theories Library},
  year = 2020,
  url = {http://smtlib.cs.uiowa.edu/theories-UnicodeStrings.shtml},
  urldate = {2020-02-11}
}

@inproceedings{regex_repeat,
author = {Chapman, Carl and Wang, Peipei and Stolee, Kathryn T.},
title = {Exploring Regular Expression Comprehension},
year = {2017},
isbn = {9781538626849},
publisher = {IEEE Press},
abstract = {The regular expression (regex) is a powerful tool employed in a large variety of software engineering tasks. However, prior work has shown that regexes can be very complex and that it could be difficult for developers to compose and understand them. This work seeks to identify code smells that impact comprehension. We conduct an empirical study on 42 of pairs of behaviorally equivalent but syntactically different regexes using 180 participants and evaluated the understandability of various regex language features. We further analyzed regexes in GitHub to find the community standards or the common usages of various features. We found that some regex expression representations are more understandable than others. For example, using a range (e.g., [0-9]) is often more understandable than a default character class (e.g., [d]). We also found that the DFA size of a regex significantly affects comprehension for the regexes studied. The larger the DFA of a regex (up to size eight), the more understandable it was. Finally, we identify smelly and non-smelly regex representations based on a combination of community standards and understandability metrics.},
booktitle = {Proceedings of the 32nd IEEE/ACM International Conference on Automated Software Engineering},
pages = {405–416},
numpages = {12},
keywords = {equivalence class, regex representations, Regular expression comprehension},
location = {Urbana-Champaign, IL, USA},
series = {ASE '17}
}

@InProceedings{prog_analysis_1,
author="Amadini, Roberto
and Jordan, Alexander
and Gange, Graeme
and Gauthier, Fran{\c{c}}ois
and Schachte, Peter
and S{\o}ndergaard, Harald
and Stuckey, Peter J.
and Zhang, Chenyi",
editor="Legay, Axel
and Margaria, Tiziana",
title="Combining String Abstract Domains for JavaScript Analysis: An Evaluation",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2017",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="41--57",
abstract="Strings play a central role in JavaScript and similar scripting languages. Owing to dynamic features such as the eval function and dynamic property access, precise string analysis is a prerequisite for automated reasoning about practically any kind of runtime property. Although the literature presents a considerable number of abstract domains for capturing and representing specific aspects of strings, we are not aware of tools that allow flexible combination of string abstract domains. Indeed, support for string analysis is often confined to a single, dedicated string domain. In this paper we describe a framework that allows us to combine multiple string abstract domains for the analysis of JavaScript programs. It is implemented as an extension of SAFE, an open-source static analysis tool. We investigate different combinations of abstract domains that capture various aspects of strings. Our evaluation suggests that a combination of a few, simple abstract domains suffice to outperform the precision of state-of-the-art static analysis tools for JavaScript.",
isbn="978-3-662-54577-5"
}

@InProceedings{prog_analysis_2,
author="Bj{\o}rner, Nikolaj
and Tillmann, Nikolai
and Voronkov, Andrei",
editor="Kowalewski, Stefan
and Philippou, Anna",
title="Path Feasibility Analysis for String-Manipulating Programs",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2009",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="307--321",
abstract="We discuss the problem of path feasibility for programs manipulating strings using a collection of standard string library functions. We prove results on the complexity of this problem, including its undecidability in the general case and decidability of some special cases. In the context of test-case generation, we are interested in an efficient finite model finding method for string constraints. To this end we develop a two-tier finite model finding procedure. First, an integer abstraction of string constraints are passed to an SMT (Satisfiability Modulo Theories) solver. The abstraction is either unsatisfiable, or the solver produces a model that fixes lengths of enough strings to reduce the entire problem to be finite domain. The resulting fixed-length string constraints are then solved in a second phase. We implemented the procedure in a symbolic execution framework, report on the encouraging results and discuss directions for improving the method further.",
isbn="978-3-642-00768-2"
}

@inproceedings{prog_analysis_3,
author = {Sen, Koushik and Kalasapur, Swaroop and Brutch, Tasneem and Gibbs, Simon},
title = {Jalangi: A Selective Record-Replay and Dynamic Analysis Framework for JavaScript},
year = {2013},
isbn = {9781450322379},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2491411.2491447},
doi = {10.1145/2491411.2491447},
abstract = {JavaScript is widely used for writing client-side web applications and is getting increasingly popular for writing mobile applications. However, unlike C, C++, and Java, there are not that many tools available for analysis and testing of JavaScript applications. In this paper, we present a simple yet powerful framework, called Jalangi, for writing heavy-weight dynamic analyses. Our framework incorporates two key techniques: 1) selective record-replay, a technique which enables to record and to faithfully replay a user-selected part of the program, and 2) shadow values and shadow execution, which enables easy implementation of heavy-weight dynamic analyses. Our implementation makes no special assumption about JavaScript, which makes it applicable to real-world JavaScript programs running on multiple platforms. We have implemented concolic testing, an analysis to track origins of nulls and undefined, a simple form of taint analysis, an analysis to detect likely type inconsistencies, and an object allocation profiler in Jalangi. Our evaluation of Jalangi on the SunSpider benchmark suite and on five web applications shows that Jalangi has an average slowdown of 26X during recording and 30X slowdown during replay and analysis. The slowdowns are comparable with slowdowns reported for similar tools, such as PIN and Valgrind for x86 binaries. We believe that the techniques proposed in this paper are applicable to other dynamic languages.},
booktitle = {Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering},
pages = {488–498},
numpages = {11},
keywords = {Concolic Testing, JavaScript, Record and Repla, Dynamic Analysis},
location = {Saint Petersburg, Russia},
series = {ESEC/FSE 2013}
}

@InProceedings{software_testing_1,
author="Amadini, Roberto
and Andrlon, Mak
and Gange, Graeme
and Schachte, Peter
and  S{\o}ndergaard, Harald
and Stuckey, Peter J.",
editor="Rousseau, Louis-Martin
and Stergiou, Kostas",
title="Constraint Programming for Dynamic Symbolic Execution of JavaScript",
booktitle="Integration of Constraint Programming, Artificial Intelligence, and Operations Research",
year="2019",
publisher="Springer International Publishing",
address="Cham",
pages="1--19",
abstract="Dynamic Symbolic Execution (DSE) combines concrete and symbolic execution, usually for the purpose of generating good test suites automatically. It relies on constraint solvers to solve path conditions and to generate new inputs to explore. DSE tools usually make use of SMT solvers for constraint solving. In this paper, we show that constraint programming (CP) is a powerful alternative or complementary technique for DSE. Specifically, we apply CP techniques for DSE of JavaScript, the de facto standard for web programming. We capture the JavaScript semantics with MiniZinc and integrate this approach into a tool we call Aratha. We use G-Strings, a CP solver equipped with string variables, for solving path conditions, and we compare the performance of this approach against state-of-the-art SMT solvers. Experimental results, in terms of both speed and coverage, show the benefits of our approach, thus opening new research vistas for using CP techniques in the service of program analysis.",
isbn="978-3-030-19212-9"
}

@InProceedings{software_testing_2,
author="Veanes, Margus
and Tillmann, Nikolai
and de Halleux, Jonathan",
editor="Clarke, Edmund M.
and Voronkov, Andrei",
title="Qex: Symbolic SQL Query Explorer",
booktitle="Logic for Programming, Artificial Intelligence, and Reasoning",
year="2010",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="425--446",
abstract="We describe a technique and a tool called Qex for generating input tables and parameter values for a given parameterized SQL query. The evaluation semantics of an SQL query is translated into a specific background theory for a satisfiability modulo theories (SMT) solver as a set of equational axioms. Symbolic evaluation of a goal formula together with the background theory yields a model from which concrete tables and values are extracted. We use the SMT solver Z3 in the concrete implementation of Qex and provide an evaluation of its performance.",
isbn="978-3-642-17511-4"
}

@InProceedings{malware_detection_1,
author="Yu, Fang
and Alkhalaf, Muath
and Bultan, Tevfik",
editor="Esparza, Javier
and Majumdar, Rupak",
title="Stranger: An Automata-Based String Analysis Tool for PHP",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2010",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="154--157",
abstract="Stranger is an automata-based string analysis tool for finding and eliminating string-related security vulnerabilities in PHP applications. Stranger uses symbolic forward and backward reachability analyses to compute the possible values that the string expressions can take during program execution. Stranger can automatically (1) prove that an application is free from specified attacks or (2) generate vulnerability signatures that characterize all malicious inputs that can be used to generate attacks.",
isbn="978-3-642-12002-2"
}

@inproceedings{malware_detection_2,
author = {Trinh, Minh-Thai and Chu, Duc-Hiep and Jaffar, Joxan},
title = {S3: A Symbolic String Solver for Vulnerability Detection in Web Applications},
year = {2014},
isbn = {9781450329576},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2660267.2660372},
doi = {10.1145/2660267.2660372},
abstract = {Motivated by the vulnerability analysis of web programs which work on string inputs, we present S3, a new symbolic string solver. Our solver employs a new algorithm for a constraint language that is expressive enough for widespread applicability. Specifically, our language covers all the main string operations, such as those in JavaScript. The algorithm first makes use of a symbolic representation so that membership in a set defined by a regular expression can be encoded as string equations. Secondly, there is a constraint-based generation of instances from these symbolic expressions so that the total number of instances can be limited. We evaluate S3 on a well-known set of practical benchmarks, demonstrating both its robustness (more definitive answers) and its efficiency (about 20 times faster) against the state-of-the-art.},
booktitle = {Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security},
pages = {1232–1243},
numpages = {12},
keywords = {web applications, string constraint solver, string analysis},
location = {Scottsdale, Arizona, USA},
series = {CCS '14}
}

@INPROCEEDINGS{malware_detection_3_kudzu,
  author={Saxena, Prateek and Akhawe, Devdatta and Hanna, Steve and Mao, Feng and McCamant, Stephen and Song, Dawn},
  booktitle={2010 IEEE Symposium on Security and Privacy}, 
  title={A Symbolic Execution Framework for JavaScript}, 
  year={2010},
  volume={},
  number={},
  pages={513-528},
  doi={10.1109/SP.2010.38}}

@misc{smt-comp,
  author = "Haniel Barbosa
  and François Bobot 
  and Jochen Hoenicke",
  title = {The 17th International Satisfiability Modulo Theories Competition (SMT-COMP 2022)},
  year = 2022,
  url = {https://smt-comp.github.io/2022/},
  urldate = {2022-8-10}
}

@InProceedings{theory_z3str3re,
author="Berzish, Murphy
and Day, Joel D.
and Ganesh, Vijay
and Kulczynski, Mitja
and Manea, Florin
and Mora, Federico
and Nowotka, Dirk",
editor="Lecroq, Thierry
and Puzynina, Svetlana",
title="String Theories Involving Regular Membership Predicates: From Practice to Theory and Back",
booktitle="Combinatorics on Words",
year="2021",
publisher="Springer International Publishing",
address="Cham",
pages="50--64",
abstract="Widespread use of string solvers in formal analysis of string-heavy programs has led to a growing demand for more efficient and reliable techniques which can be applied in this context, especially for real-world cases. Designing an algorithm for the (generally undecidable) satisfiability problem for systems of string constraints requires a thorough understanding of the structure of constraints present in the targeted cases. In this paper, we investigate benchmarks presented in the literature containing regular expression membership predicates, extract different first order logic theories, and prove their decidability, resp. undecidability. Notably, the most common theories in real-world benchmarks are {\$}{\$}{\backslash}mathsf {\{}PSPACE{\}}{\$}{\$}PSPACE-complete and directly lead to the implementation of a more efficient algorithm to solving string constraints.",
isbn="978-3-030-85088-3"
}

@misc{automatark,
  author = "Loris D'Antoni",
  title = {Automatark automata benchmark (2018).},
  year = 2018,
  url = {https://github.com/lorisdanto/automatark},
  urldate = {2018-06-24}
}

@inproceedings{regex_lingua_franca,
author = "Davis, James C.
and Michael IV, Louis G. 
and Coghlan, Christy A. 
and Servant, Francisco 
and Lee, Dongyoon",
title = {Why Aren’t Regular Expressions a Lingua Franca? An Empirical Study on the Re-Use and Portability of Regular Expressions},
year = {2019},
isbn = {9781450355728},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3338906.3338909},
doi = {10.1145/3338906.3338909},
abstract = {This paper explores the extent to which regular expressions (regexes) are portable across programming languages. Many languages offer similar regex syntaxes, and it would be natural to assume that regexes can be ported across language boundaries. But can regexes be copy/pasted across language boundaries while retaining their semantic and performance characteristics? In our survey of 158 professional software developers, most indicated that they re-use regexes across language boundaries and about half reported that they believe regexes are a universal language.We experimentally evaluated the riskiness of this practice using a novel regex corpus — 537,806 regexes from 193,524 projects written in JavaScript, Java, PHP, Python, Ruby, Go, Perl, and Rust. Using our polyglot regex corpus, we explored the hitherto-unstudied regex portability problems: logic errors due to semantic differences, and security vulnerabilities due to performance differences. We report that developers’ belief in a regex lingua franca is understandable but unfounded. Though most regexes compile across language boundaries},
booktitle = {Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
pages = {443–454},
numpages = {12},
keywords = {ReDoS, Regular expressions, re-use, developer perceptions, empirical software engineering, portability, mining software repositories},
location = {Tallinn, Estonia},
series = {ESEC/FSE 2019}
}


@inproceedings{z3str4,
author = {Mora, Federico and Berzish, Murphy and Kulczynski, Mitja and Nowotka, Dirk and Ganesh, Vijay},
title = {Z3str4: A Multi-Armed String Solver},
year = {2021},
isbn = {978-3-030-90869-0},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-030-90870-6_21},
doi = {10.1007/978-3-030-90870-6_21},
abstract = {We present Z3str4, a new high-performance string SMT solver for a rich quantifier-free first-order theory of strings and length constraints. These kinds of constraints have found widespread application in analysis of string-intensive programs in general, and web applications in particular. Three key contributions underpin our solver: first, a novel length-abstraction algorithm that performs various string-length based abstractions and refinements along with a bit-vector backend; second, an arrangement-based solver with a bit-vector backend; third, an algorithm selection and constraint-sharing architecture which leverages the above-mentioned solvers along with the Z3 sequence (Z3seq) solver. We perform extensive empirical evaluation over 20 different industrial and randomly-generated benchmarks with over 120,000+ instances, and show that Z3str4 outperforms the previous best solvers, namely, CVC4, Z3seq, and Z3str3 in both total solved instances and total runtime.},
booktitle = {Formal Methods: 24th International Symposium, FM 2021, Virtual Event, November 20–26, 2021, Proceedings},
pages = {389–406},
numpages = {18},
keywords = {SMT, String solvers, Program analysis}
}



