%!TEX root = ../main.tex
%\documentclass[11pt]{standalone}
%\begin{document}

In modern programming languages---such as JavaScript, Python, Java, and PHP---the string data type plays a crucial role. 
It is well-known that string manipulations are error-prone and could even give rise to security vulnerabilities (e.g. \ cross-site scripting, aka XSS). 
One powerful method for identifying such bugs in programs is \emph{symbolic execution} (possibly in combination with dynamic analysis), which analyses symbolic paths in a program by viewing them as constraints, whose feasibility is checked by constraint solvers. 
%
Symbolic execution of string manipulating programs has motivated the highly active research area of \emph{string constraint solving}, resulting in the development of numerous string solvers in the last decade, including the state-of-the-art string constraint solvers, e.g.
Z3seq~\cite{z3seq}, CVC4/5~\cite{cvc4}, Z3str/2/3/4~\cite{Z3-str,Z3-str2,Z3-str3,BerzishMurphy2021}, Z3str3RE~\cite{BD+23}, 
Z3-Trau~\cite{Z3-trau}, OSTRICH~\cite{CHL+19}, Slent~\cite{WC+18}, among many others. 

Regular expressions (abbreviated as regex) and string-length function are widely used in string-manipulating programs. According to the statistics from \cite{CS16,DCSL18,WS18}, regular expressions are used in about 30â€“40\% Java, JavaScript, and Python software projects. 
Moreover, that string-length function occupies 78\% of the occurrences of string operations in 18 Javascript applications, according to the statistics from \cite{malware_detection_3_kudzu}. 
%Operations like \verb|length| that take string inputs and return an integer frequently appear in real-world JavaScript applications (78\% of string operations in 18 applications)
As a result, most of the aforementioned string constraint solvers support both regular expressions and string-length function. Moreover, specialized algorithms have been proposed to efficiently solve the class of string constraints with regular expressions and string-length function \cite{LTR+15,BD+23}. 
%a decision procedure based on tableaux calculus was designed in \cite{LTR+15} for the class of string constraints with regular expressions and string-length function. The decision procedure has been implemented in CVC4/5 \cite{LRT+16}.

Counting (aka repetition) is a convenient feature in regular expressions that count the number of matchings of sub-patterns. For instance, $a^{\{2, 4\}}$ specifies that $a$ occurs at least twice and at most four times, and $a^{\{2, \infty\}}$ specifies that $a$ occurs at least twice. 
Note that Kleene star and Kleene plus operator can be seen as special cases of counting operator. For instance, $a^*$ and $a^+$ are equivalent to $a^{\{0,\infty\}}$ and $a^{\{1,\infty\}}$.
Counting is a frequently used feature of regular expressions. According to the statistics from \cite{CS16}, Kleene star/plus occur in more than 70\% of 1,204 Python projects, while the other forms of counting occur in more than 20\% of them. Therefore, an efficient analysis of string manipulating programs requires efficient solvers for string constraints that contain at least regular expressions with counting\footnote{In the rest of this paper, for clarity, we use counting to denote expressions of the form $e^{\{m, n\}}$ and  $e^{\{m, \infty\}}$, but not $e^*$ or $e^+$.} and string-length function. 

Nevertheless, the aforementioned state-of-the-art string constraint solvers still suffer from string constraints with regex-counting and string-length, especially when the counting bounds are large. For instance, none of the string solvers CVC5, Z3seq, Z3-Trau, Z3str3, Z3str3RE, and OSTRICH is capable of solving the following constraint within 300 seconds,
%
\begin{equation}\label{eqn-running}
x \in (\Sigma \setminus a)^{\{1, 60\}} (\Sigma \setminus b)^{\{1, 60\}} (\Sigma \setminus c)^{\{0, 60\}} \wedge x \in \Sigma^* c^+ \wedge |x| > 120.
\end{equation}
Intuitively, the constraint in (\ref{eqn-running}) specifies that $x$ is a concatenation of three strings $x_1, x_2, x_3$ where $a$ (resp. $b, c$) does not occur in $x_1$ (resp. $x_2, x_3$), moreover, $x$ ends with a nonempty sequence of $c$'s, and the length of $x$ is greater than $120$. It is easy to observe that this constraint is unsatisfiable since on the one hand, $|x| > 120$ and the counting upper bound $60$ in both $(\Sigma \setminus a)^{\{1, 60\}}$ and $(\Sigma \setminus b)^{\{1, 60\}}$ imply that $x$ must end with some character from $\Sigma \setminus c$, that is, a character different from $c$, and on the other hand, $x \in \Sigma^*c^+$ requires that $x$ has to end with $c$.

A typical way for string constraint solvers to deal with regex-counting is to unfold regular expressions with counting into those \emph{without} counting by using the concatenation operator. For instance, $a^{\{1, 4\}}$ is unfolded into $a(\varepsilon + a + aa + aaa)$ and $a^{\{2,\infty\}}$ is unfolded into $aaa^{*}$. Since the unfolding incurs an exponential blow-up on the sizes of constraints (assuming that the integer constants in string constraints are encoded in binary), the unfolding penalizes the performance of the solvers, especially when the bounds are large. 

%counting is used in about 6 percent of the regular expressions in Javascript programs. 

\medskip
\noindent 
\emph{Contribution.} In this work, we focus on the class of string constraints with regular membership and string-length function, where the counting operators may occur in regular expressions (called RECL for brevity). We propose an automata-theoretical approach for solving RECL constraints. Our main idea is to represent the counting operators by registers in automata (as much as possible), instead of unfolding them explicitly. Our approach is built upon an automata model called cost-enriched finite automata (CEFA), which was proposed in~\cite{atva2020} to solve string constraints involving the integer data type. Moreover, the string-length function can also be modeled by registers in CEFA. Then the satisfiability of RECL constraints is reduced to the nonemptiness problem of CEFA with respect to a linear integer arithmetic (LIA) formula whose free variables are registers of CEFA. 

According to the results from~\cite{atva2020}, an LIA formula can be computed to represent the potential values of registers in CEFA. Thus, the nonemptiness of CEFA w.r.t. LIA formulas can be reduced to the satisfiability of LIA formulas, which is then tackled by off-the-shelf SMT solvers for LIA. 
%
Because the sizes of LIA formulas depend much on the sizes of CEFA, it is beneficial to reduce the sizes of CEFA, in order to achieve a good performance. As a result, we propose various techniques to reduce the state space and the number of transitions of CEFA. Furthermore, since the computation of LIA formulas from CEFA is relatively expensive, we also propose a method of searching for strings that are accepted by CEFA, based on under approximations, before constructing the LIA formulas.  

The representation of regex-counting and string-length as registers in CEFA, combined with the aforementioned size-reduction and under-approximation techniques, entails an efficient algorithm for solving RECL constraints. We implement the algorithm on top of OSTRICH, resulting in a new version of OSTRICH, called $\ostrichrecl$ for convenience. 
%
Furthermore, we utilize a collection of benchmark suites, which comprise 48,834 RECL constraints in total, to evaluate the performance of $\ostrichrecl$. The collection of benchmark suites includes a widely-used benchmark suite for string constraints, as well as benchmark suites comprising constraints generated from regular expressions in various open source regex libraries. 
%
%Note that in the benchmark suites, we only consider the regexes that contain explicit counting, that is, regexes that contain sub-expressions of the form $e^{\{n, m\}}$, and ignore those that contain only implicit counting operators, that is, $e^*$ or $e^+$, since the state-of-the-art string solvers suffer mainly from the explicit counting operators. 
%
The experiment results show that $\ostrichrecl$ can solve 48,698 out of 48,834 instances, while Z3str3RE, the state-of-the-art best solver on RECL constraints, solves only 47,607 instances (where the timeout period is set as 60 seconds). Moreover, the speed of $\ostrichrecl$ is comparable to that of Z3str3RE. In comparison, CVC5, Z3seq, Z3-Trau, and Z3str3 solve only 44,704, 46,426, 24,121, and 35,866 instances respectively. (See Table~\ref{tab:results_regcol} and Table~\ref{tab:results_automatark} for more details.)

At last, we would like to clarify the relationship of this work with~\cite{atva2020}, where CEFA was introduced. This work differs from \cite{atva2020} in the following aspects: In \cite{atva2020}, regex-counting was unfolded explicitly. Moreover, in~\cite{atva2020}, the nonemptiness of CEFA w.r.t. LIA formulas was solved by utilizing the nuXmv model checker~\cite{nuxmv}. In contrast, this work solves it by integrating the techniques of Parikh-image computation, automata-size reduction, and under approximation. The experimental results show that our approach solves 7,092 more instances than the solver in~\cite{atva2020} while spending less time. (See Table~\ref{tab:results_regcol} and Table~\ref{tab:results_automatark} for more details, where OSTRICH denotes the solver in \cite{atva2020}.)

\medskip
\noindent
\emph{Related work.} 
We discuss more related work about regexes with counting and real-world regexes in programming languages.  
The determinism of regexes with counting was investigated in~\cite{GGM12,CL15}. Counting-set automata were proposed in~\cite{redos_lenka,HS+23} to match a subclass of regexes with counting quickly. Moreover, a variant of nondeterministic counter automata, called bit vector automata, was proposed recently in \cite{GKM23} to enable fast matching of a more expressive class of regexes with counting.   Nevertheless, the nonemptiness problem of these automata was not considered in ~\cite{redos_lenka,HS+23,GKM23}, and it is unclear whether these automata models can be used for solving string constraints with regex-counting and string-length.
Real-world regexes in programming languages include features beyond classical regular expressions, e.g. the greedy/lazy Kleene star, capturing groups, and back references. Real-world regexes have been addressed in symbolic execution of Javascript programs~\cite{LMK19} and string constraint solving~\cite{CF+22}. Nevertheless, the counting operators are still unfolded explicitly in~\cite{CF+22}.  

%To handle the problems in software verification reasoning about strings and integers, string theories with regular membership predicate and linear length constraints are raised. String solvers such as Z3Str3\cite{z3str3}, Z3Seq\cite{z3seq}, BD+23\cite{BD+23}, CVC4\cite{cvc4}, CVC5\cite{cvc5}, (Z3-)Trau\cite{trau}\cite{z3trau}, Ostrich(+)\cite{ostrich}\cite{atva2020}, Sloth\cite{sloth}, S3\cite{s3}, and ABC\cite{abc} are developed on these theories. Although string theory is easily
%undecidable\cite{undecidable_1}\cite{undecidable_2}, the satisfiability problems for string constraints of regular expressions, linear integer arithmetic, and the string length is decidable\cite{theory_BD+23}. There are mainly two strategies for solving string constraints: (1) DPLL(T)-based\cite{dpll_t} string solvers\cite{z3str3}\cite{cvc5} apply heuristic derivation rules to unwind the regular expression gradually and identify several classes of simplification techniques for efficiency. (2) Automata-based string solvers\cite{trau}\cite{z3trau}\cite{ostrich}\cite{atva2020}\cite{BD+23} construct a finite automaton to model the regular expression and use the emptiness problem of the automaton (under linear integer arithmetic) to decide the satisfiability of string constraints. 

\smallskip
\noindent
\emph{Organization.} 
The rest of this paper is structured as follows: Section~\ref{sec:overview} gives an overview of the approach in this paper. Section~\ref{sec:pre} introduces the preliminaries. 
Section~\ref{sec:recl} presents the syntax and semantics of RECL. 
Section~\ref{sec:automaton} defines CEFA. Section~\ref{sec:algorithm} introduces the algorithm to solve RECL constraints. Section~\ref{sec:implementation} shows the experiment results. Section~\ref{sec:conclu} concludes this paper.


%%%%%%%%%%%%%%%%%%%%%%% original texts by Denghang %%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%% original texts by Denghang %%%%%%%%%%%%%%%%%
\hide{
String constraint solving is a subfield of computer science that deals with analyzing and manipulating strings, which are sequences of characters. String constraints solving aim to automatically infer properties of string variables, such as their length, content, and structure, to reason about the behavior of software systems that manipulate strings. It is crucial in security-critical applications, where strings represent sensitive data such as passwords, user input, and network addresses. String constraints solving combines techniques from formal methods, automata theory, and constraint solving and has many applications in areas such as software testing\cite{software_testing_1}\cite{software_testing_2}, program analysis\cite{prog_analysis_1}\cite{prog_analysis_2}\cite{prog_analysis_3}, and malware detection\cite{malware_detection_1}\cite{malware_detection_2}\cite{malware_detection_3_kudzu}. In this context, efficient algorithms and tools for solving string constraints are crucial to improve the security and reliability of modern software systems.\newline
Regular expressions are widely used in programming languages. About 30â€“40 \%
Java, JavaScript, and Python software use regex matching\cite{redos_fse2019}. Bounded repetition is widely used in regex matching\cite{regex_repeat} and is dangerous because Regular expression Denial of Service (ReDoS) may derive from it\cite{redos_lenka}. We have analyzed regular expressions sourced from the Internet\cite{regexlib}\cite{stackoverflow}, among which about 10\% include bounded repetition. Operations like \verb|length| that take string inputs and return an integer frequently appear in real-world JavaScript applications (78\% of string operations in 18 applications\cite{malware_detection_3_kudzu}). These statistics show that a resultful string solver reasoning about regular membership predicate with bounded repetition and \verb|length| operation is required. However, such string constraints may lead to low performance. 
% the state-of-art string solvers (\cite{z3seq}\cite{z3str3}\cite{z3str4}\cite{BD+23}\cite{cvc5}\cite{ostrich}\cite{z3trau}\cite{trau}) lose efficiency. 
For CVC5\cite{cvc5} (which is the winner of QF\_Strings track in SMT-COMP 2022\cite{smt-comp}), the string constraints are solved based on DPLL(T) structure. Each string constraint is seen as a literal boolean and assigned by true or false (Boolean abstraction). CVC5 repeatedly applies derivation rules on these assigned string constraints until the satisfiable solution is found or unsatisfiability is detected. The approach is fast and sound. Nevertheless, it is incomplete because it may not recognize unsatisfiable literals and may not terminate when unrolling regular expression. For example, CVC5 unrolls regular expression $\Sigma_{/a}\{1,300\}$ and $\Sigma^*a\Sigma^*$ when solving the string constraints \ref{eq:cvc5_timeout}. $\Sigma_{/a}\{1,300\}$ repeats a letter excluding $a$ from one time to 300 times. $\Sigma^*a\Sigma^*$ accepts a string containing $a$. It is easy to see that the string constraints are unsat.
However, CVC5 is hard to explore the unsatisfiability, for it can only answer once attempting all strings with lengths less than or equal to 300. The number of the searched string is exponential to the count. We test this instance on CVC5 and get a timeout result when the timeout is set to 60s.
\begin{equation} \label{eq:cvc5_timeout}
  x\in \Sigma_{/a}\{1,300\}\wedge x\in \Sigma^*a\Sigma^*
\end{equation}
Z3Str3\cite{z3str3} is a string solver written on the famous SMT solver Z3\cite{Z3}. It is based on the DPLL(T) structure and uses the same approach as CVC5, except that the derivation rules of Z3 differ from CVC5. Furthermore, Z3str3 exposes the structure of theory literals to the DPLL(T) SAT solver's branching heuristic, resulting in smarter decisions during its search. Z3Str3 can not solve string constraints (\ref{eq:cvc5_timeout}) as well because the optimization can not avoid the endless unwind of the regular expression. To handle the exponential search space of regular expression, automata-based methods were proposed. One of the automata-based string solver Ostrich\cite{ostrich}\cite{atva2020} encodes string constraints and regular expressions into automata and use the automata theory to solve them. It is sound and complete. But it is inefficient because it is hard to reduce the size of automata. When large counting is constrained on a complex sub-regex, like $ \backslash w \{1, 63\}$ where $\backslash w$ is an English character or a number character, the corresponding automaton in Ostrich becomes very large and can not be solved within 60s time limit. The reason is that Ostrich syntactically rewrites the counting operator to the union of finite repeatings of the sub-regex. For example, $\backslash w\{1, 63\}$ is rewritten to $\backslash w\mid\backslash w^2\cdots\mid\backslash w^{63}$ where $\backslash w^i$ means repeat $i\-th$ times on $\backslash w$. The automaton of $\backslash w$ contains $62$ states to accept each possible character, and the automaton of $\backslash w ^i$ contains $62*i$ states. The total number of states in the automaton is $62 + 62*2 + \cdots 62*63=124992$, causing the automaton to be unsolvable in practice. Trau\cite{z3trau}\cite{trau+} is another powerful automata-based solver. It relies on a Counter-Example Guided Abstraction Refinement (CEGAR) framework in which the under- and over-approximation of the automata are iteratively refined. Although it uses simple flat automata to represent regular expressions, it has to build unsolvable automata on regex $\backslash w\{1, 63\}$ as Ostrich because the solution of the flat automata should be within the solution of the original automata. 
Recently, Z3str3 has been extended to BD+23\cite{BD+23} by Berzish et al to handle string constants with regular memberships and length operation effectively. It uses automata to formalize the semantic of regular expression and applies several length-aware heuristics. BD+23 can avoid building unsolvable automaton because the length abstraction is directly derived from the regex, not the automaton. Unfortunately, the length abstraction is an over-approximation, so it can not solve string constraints (\ref{eq:BD+23_timeout}) whose regular membership predicate contains complementary.
\begin{equation}\label{eq:BD+23_timeout}
  x\in \Sigma_{/a}\{13,13\}\wedge |x| > 13
\end{equation}
To address these issues, we formalize bounded repetition using cost-enriched finite automaton (CEFA)\cite{atva2020} with linear arithmetical constraints. It limits the max(min) run times of some transitions on the accepting run of the automaton, which completely captures the semantics of bounded repetition. The satisfiability problem of string constraints with bounded repetition is reduced to the emptiness problem of cost-enriched finite automata under linear arithmetical constraints (abbreviated as $SAT_{CL}$ problem), which is decidable and can be solved by our previous work \cite{atva2020}. However, the previous work could perform better practically, especially when regular expressions are complex. In this paper, we propose two heuristical methods to improve performance. The first one is under-approximation, which is inspired by Bounded Model Checking \cite{bmc_1}\cite{bmc_2}\cite{bmc_3}. The second one is the symbolic-aware simplification, which is motivated by the observation that the emptiness problem is only related to the symbolic update functions. We implement a powerful string solver OstrichCEA and evaluate it on instances from the real world and other typical benchmarks. The experiment result shows superiority.

\subsubsection{Related Work}
To handle the problems in software verification reasoning about strings and integers, string theories with regular membership predicate and linear length constraints are raised. String solvers such as Z3Str3\cite{z3str3}, Z3Seq\cite{z3seq}, BD+23\cite{BD+23}, CVC4\cite{cvc4}, CVC5\cite{cvc5}, (Z3-)Trau\cite{trau}\cite{z3trau}, Ostrich(+)\cite{ostrich}\cite{atva2020}, Sloth\cite{sloth}, S3\cite{s3}, and ABC\cite{abc} are developed on these theories. Although string theory is easily
undecidable\cite{undecidable_1}\cite{undecidable_2}, the satisfiability problems for string constraints of regular expressions, linear integer arithmetic, and the string length is decidable\cite{theory_BD+23}. There are mainly two strategies for solving string constraints: (1) DPLL(T)-based\cite{dpll_t} string solvers\cite{z3str3}\cite{cvc5} apply heuristic derivation rules to unwind the regular expression gradually and identify several classes of simplification techniques for efficiency. (2) Automata-based string solvers\cite{trau}\cite{z3trau}\cite{ostrich}\cite{atva2020}\cite{BD+23} construct a finite automaton to model the regular expression and use the emptiness problem of the automaton (under linear integer arithmetic) to decide the satisfiability of string constraints. 


\subsubsection{Our Contributions}
Our main contributions are as follows:
\begin{enumerate}
  \item  Encode regular expression with bounded repetition into CEFA with linear arithmetical constraints.
  \item  Devise heuristic methods like under-approximation and symbolic-aware simplification to solve the $SAT_{CL}$ problem.
  \item  Generate significant instances with bounded repetition from real-world regular expressions.
  \item  Implement our decision procedure on solver OstrichCEA and compare it with state-of-art string solvers. The result shows the superiority of our encoding and heuristics.
\end{enumerate}

The rest of the paper is structured as follows: Section \ref{sec:pre} introduces the preliminaries. Section \ref{sec:overview} outlines the overall algorithm. Section \ref{sec:automaton} illustrates how to construct an automaton from a regular expression. Section \ref{sec:algorithm} shows how to solve a string constraint with repetition. Section \ref{sec:implementation} presents the experimental results. Section \ref{sec:conclu} concludes the paper and discusses future work.
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\end{document}