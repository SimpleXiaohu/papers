%!TEX root = ../main.tex
%\documentclass[11pt]{standalone}
%\begin{document}

The string data type plays a crucial role in modern programming languages such as JavaScript, Python, Java, and PHP. 
String manipulations are error-prone and could even give rise to severe security vulnerabilities (e.g., cross-site scripting, aka XSS). 
One powerful method for identifying such bugs is \emph{symbolic execution}, which is possibly in combination with dynamic analysis. It analyses symbolic paths in a program by viewing them as constraints checked by constraint solvers. 
%
Symbolic execution of string manipulating programs has motivated the highly active research area of \emph{string constraint solving}, resulting in the development of numerous string solvers in the last decade, e.g.,
Z3seq~\cite{z3seq}, CVC4/5~\cite{cvc4}, Z3str/2/3/4~\cite{Z3-str,Z3-str2,Z3-str3,BerzishMurphy2021}, Z3str3RE~\cite{BD+23}, 
Z3-Trau~\cite{Z3-trau}\cite{z3trau}, OSTRICH~\cite{CHL+19}, Slent~\cite{WC+18}, among many others. 

Regular expressions (regex for short) and the string-length function are widely used in string-manipulating programs. According to the statistics from \cite{CS16,DCSL18,WS18}, regular expressions are used in about 30â€“40\% of Java, JavaScript, and Python software projects. 
Moreover, string-length occupies 78\% of the occurrences of string operations in 18 Javascript applications, according to the statistics from \cite{malware_detection_3_kudzu}. 
%Operations like \verb|length| that take string inputs and return an integer frequently appear in real-world JavaScript applications (78\% of string operations in 18 applications)
As a result, most of the aforementioned string constraint solvers support both regular expressions and string-length function. Moreover, specialized algorithms have been proposed to solve such string constraints efficiently. \cite{LTR+15,BD+23}. 
%a decision procedure based on tableaux calculus was designed in \cite{LTR+15} for the class of string constraints with regular expressions and string-length function. The decision procedure has been implemented in CVC4/5 \cite{LRT+16}.

Counting (aka repetition) is a convenient feature in regular expressions that count the number of matchings of sub-patterns. For instance, $a^{\{2, 4\}}$ specifies that $a$ occurs at least twice and at most four times, and $a^{\{2, \infty\}}$ specifies that $a$ occurs at least twice. 
Note that the Kleene star and the Kleene plus operator are special cases of counting. For instance, $a^*$ is equivalent to $a^{\{0,\infty\}}$ and $a^+$ are equivalent to $a^{\{1,\infty\}}$.
Counting is a frequently used feature of regular expressions. According to the statistics from \cite{CS16}, Kleene star/plus occur in more than 70\% of 1,204 Python projects, while other forms of counting occur in more than 20\% of them. Therefore, an efficient analysis of string manipulating programs requires efficient solvers for string constraints containing regular expressions with counting\footnote{In the rest of this paper, for clarity, we use counting to denote expressions of the form $e^{\{m, n\}}$ and  $e^{\{m, \infty\}}$, but not $e^*$ or $e^+$.} and string-length function at least. 

Nevertheless, the aforementioned state-of-the-art string constraint solvers still suffer from such string constraints, especially when the counting and length bounds are large. For instance, none of the string solvers CVC5, Z3seq, Z3-Trau, Z3str3, Z3str3RE, and OSTRICH is capable of solving the following constraint within 120 seconds.
%, and Z3 can not solve it within 120 seconds.
%
\begin{equation}\label{eqn-running}
x \in (\Sigma \setminus a)^{\{1, 60\}} (\Sigma \setminus b)^{\{1, 60\}} (\Sigma \setminus c)^{\{0, 60\}} \wedge x \in \Sigma^* c^+ \wedge |x| > 120.
\end{equation}
Intuitively, the constraint in (\ref{eqn-running}) specifies that $x$ is a concatenation of three strings $x_1, x_2, x_3$ where $a$ (resp. $b, c$) does not occur in $x_1$ (resp. $x_2, x_3$), moreover, $x$ ends with a nonempty sequence of $c$'s, and the length of $x$ is greater than $120$. It is easy to observe that this constraint is unsatisfiable since on the one hand, $|x| > 120$ and the counting upper bound $60$ in both $(\Sigma \setminus a)^{\{1, 60\}}$ and $(\Sigma \setminus b)^{\{1, 60\}}$ imply that $x$ must end with some character from $\Sigma \setminus c$, that is, a character different from $c$, and on the other hand, $x \in \Sigma^*c^+$ requires that $x$ has to end with $c$.

A typical way for string constraint solvers to deal with regular expressions with counting is to unfold them into those \emph{without} counting using the concatenation operator. For instance, $a^{\{1, 4\}}$ is unfolded into $a(\varepsilon + a + aa + aaa)$ and $a^{\{2,\infty\}}$ is unfolded into $aaa^{*}$. Since the unfolding incurs an exponential blow-up on the sizes of constraints (assuming that the counting in string constraints are encoded in binary), the unfolding penalizes the performance of the solvers, especially when the length bounds are also available.

%counting is used in about 6 percent of the regular expressions in Javascript programs. 

\medskip
\noindent 
\emph{Contribution.} In this work, we focus on the class of string constraints with regular membership and string-length function, where the counting operators may occur (called RECL for brevity). We make the following contributions.
\vspace{-0.5mm}
\begin{itemize}
  \item We propose an automata-theoretical approach for solving RECL constraints. 
  Our main idea is to represent the counting operators by cost registers in cost-enriched finite automata (CEFA, see Section~\ref{sec:automaton} for the definition), instead of unfolding them explicitly. The string-length function is modeled by cost registers as well. The satisfiability of RECL constraints is reduced to the nonemptiness problem of CEFA w.r.t. a linear integer arithmetic (LIA) formula. According to the results from~\cite{atva2020}, an LIA formula can be computed to represent the potential values of registers in CEFA.
Thus, the nonemptiness of CEFA w.r.t. LIA formulas can be reduced to the satisfiability of LIA formulas, which is then tackled by off-the-shelf SMT solvers.
%
  % Moreover, the string-length function can also be modeled by register in CEFA. Then the satisfiability of RECL constraints is reduced to the nonemptiness problem of CEFA with respect to a linear integer arithmetic (LIA) formula whose free variables are registers. According to the results from~\cite{atva2020}, an LIA formula can be computed to represent the potential values of registers in CEFA. 
  % Thus, the nonemptiness of CEFA w.r.t. LIA formulas can be reduced to the satisfiability of LIA formulas, which is then tackled by off-the-shelf SMT solvers.
  \item We propose techniques to reduce the sizes (i.e. the number of states and transitions) of CEFA, in order to achieve better performance.
%  , since the sizes of LIA formulas depend much on the sizes of CEFA.
  \item Combined with the size-reduction techniques mentioned above, the register representation of regex-counting and string-length in CEFA entails an efficient algorithm for solving RECL constraints. We implement the algorithm on top of OSTRICH, resulting in a string solver called $\ostrichrecl$. 
 %
  \item Finally, we utilize a collection of benchmark suites comprising 48,843 instances in total to evaluate the performance of $\ostrichrecl$. The experiment results show that $\ostrichrecl$ solves the RECL constraints more efficiently than the state-of-the-art string solvers, especially when the counting and length bounds are large (see Table~\ref{tab:results_regcol} and Figure~\ref{fig:table_large_count}). For instance, on 1,873 benchmark instances where the counting bounds are greater than or equal to $50$ and the string lengths are required to be beyond $200$, $\ostrichrecl$ solves at least $278$ more instances than the other solvers, while spending only half or less time per instance on average. 
%  For instance,  the most number of instances than the other solvers, with comparable or faster speed (See Table~\ref{tab:results_regcol}). Moreover, when the counting and length bounds are large, $\ostrichrecl$ solves much more instances than the other solvers, while using much less time.  

%In addition, we carry out some detailed experiments, including the evaluation of simplification techniques and the experiment of large-counting benchmarks. The result shows that the simplification techniques are effective in practice (See Table~\ref{tab:results_simp}), and $\ostrichrecl$ performs much better than other solvers on the large-counting benchmark (See Fig~\ref{fig:table_large_count}).

% The experiment results show that $\ostrichrecl$ can solve 48,698 out of 48,843 instances, while Z3str3RE, the state-of-the-art solver on RECL constraints, solves only 47,607 instances (where the timeout period is set as 60 seconds). Moreover, the speed of $\ostrichrecl$ is comparable to that of Z3str3RE. In comparison, CVC5, Z3seq, Z3-Trau, and Z3str3 solve only 44,704, 46,426, 24,121, and 35,866 instances respectively. (See Table~\ref{tab:results_regcol}-\ref{tab:results_summary} for more details.)
\end{itemize}
\vspace{-0.5mm}
% We propose an automata-theoretical approach for solving RECL constraints. Our main idea is to represent the counting operators by registers in automata (as much as possible) instead of unfolding them explicitly. Our approach is built upon cost-enriched finite automata (CEFA), proposed in~\cite{atva2020} to solve string constraints involving the integer data type. Moreover, the string-length function can also be modeled by register in CEFA. Then the satisfiability of RECL constraints is reduced to the nonemptiness problem of CEFA with respect to a linear integer arithmetic (LIA) formula whose free variables are registers of CEFA. 

% According to the results from~\cite{atva2020}, an LIA formula can be computed to represent the potential values of registers in CEFA. Thus, the nonemptiness of CEFA w.r.t. LIA formulas can be reduced to the satisfiability of LIA formulas, which is then tackled by off-the-shelf SMT solvers for LIA. Because the sizes of LIA formulas depend much on the sizes of CEFA, it is beneficial to reduce the sizes of CEFA to achieve better performance. As a result, we propose various techniques to reduce the state space and the number of transitions of CEFA. 

% Combined with the simplification techniques mentioned above, the register representation of regex-counting and string-length in CEFA entails an efficient algorithm for solving RECL constraints. We implement the algorithm on top of OSTRICH, resulting in a new version of OSTRICH called $\ostrichrecl$ for convenience. 
% Furthermore, we utilize a collection of benchmark suites comprising 48,843 RECL constraints in total to evaluate the performance of $\ostrichrecl$. It includes a widely-used benchmark suite for string constraints and benchmark suites comprising constraints generated from regular expressions in various open source regex libraries. 
% %
% %Note that in the benchmark suites, we only consider the regexes that contain explicit counting, that is, regexes that contain sub-expressions of the form $e^{\{n, m\}}$, and ignore those that contain only implicit counting operators, that is, $e^*$ or $e^+$, since the state-of-the-art string solvers suffer mainly from the explicit counting operators. 
% %
% The experiment results show that $\ostrichrecl$ can solve 48,698 out of 48,843 instances, while Z3str3RE, the state-of-the-art best solver on RECL constraints, solves only 47,607 instances (where the timeout period is set as 60 seconds). Moreover, the speed of $\ostrichrecl$ is comparable to that of Z3str3RE. In comparison, CVC5, Z3seq, Z3-Trau, and Z3str3 solve only 44,704, 46,426, 24,121, and 35,866 instances respectively. (See Table~\ref{tab:results_regcol}-\ref{tab:results_summary} for more details.)

% At last, we would like to clarify the relationship of this work with~\cite{atva2020}, where CEFA was introduced. This work differs from \cite{atva2020} in the following two aspects: (1) In \cite{atva2020}, regex-counting was unfolded explicitly while this work encodes it to register. (2) Moreover, the nonemptiness of CEFA w.r.t. LIA formulas was solved using the nuXmv model checker~\cite{nuxmv}. In contrast, this work solves it by integrating the techniques of Parikh-image computation and automata-size reduction. The experimental results show that our approach solves 7,092 more instances than the solver in~\cite{atva2020} while spending less time. (See Table~\ref{tab:results_regcol}-\ref{tab:results_summary} for more details.)

\medskip
\noindent
\emph{Related work.} 
We discuss more related work about regexes with counting in programming languages.  
The determinism of regexes with counting was investigated in~\cite{GGM12,CL15}. Counting-set automata were proposed in~\cite{redos_lenka,HS+23} to quickly match a subclass of regexes with counting. Moreover, a variant of nondeterministic counter automata, called bit vector automata, was proposed recently in \cite{GKM23} to enable fast matching of a more expressive class of regexes with counting.   Nevertheless, the nonemptiness problem of these automata was not considered, and it is unclear whether these automata models can be used for solving string constraints with regex-counting and string-length. \denghang{For the automata model, the definition of registers of CEFAs resembles the counters of the counter automata class~\cite{GGM12,redos_lenka,HS+23,GKM23}, but CEFAs contain no guards in each transition. Register automata~\cite{ra} and symbolic register automata~\cite{sra} utilize registers to store input variables (i.e., the letters of the alphabet), on which only equality and inequality are permitted. In contrast, CEFAs utilize registers to store integers constrained by linear arithmetic formulae.}
Real-world regexes in programming languages include features beyond classical regular expressions, e.g., the greedy/lazy Kleene star, capturing groups, and back references. Real-world regexes have been addressed in symbolic execution of Javascript programs~\cite{LMK19} and string constraint solving~\cite{CF+22}. Nevertheless, the counting operators are still unfolded explicitly in~\cite{CF+22}. \sout{Solving string constraints involving lengths has also been investigated by various researchers, see e.g. \cite{WC+18,atva2020,z3str3re}.} \denghang{Except for the string solvers mentioned before, some related works about string constraints with the length function exist. Trau~\cite{z3trau} relies on a Counter-Example Guided Abstraction Refinement (CEGAR) framework in which the under- and over-approximation of the automata are iteratively refined to solve length and regex constraints. Slent~\cite{WC+18} transfers the string and length constraints to length-encoded automata, and leverages a symbolic model checker as an engine for the emptiness checking of automata. However, both Trau and Slent do not support counting operators.}

%To handle the problems in software verification reasoning about strings and integers, string theories with regular membership predicate and linear length constraints are raised. String solvers such as Z3Str3\cite{z3str3}, Z3Seq\cite{z3seq}, BD+23\cite{BD+23}, CVC4\cite{cvc4}, CVC5\cite{cvc5}, (Z3-)Trau\cite{trau}\cite{z3trau}, Ostrich(+)\cite{ostrich}\cite{atva2020}, Sloth\cite{sloth}, S3\cite{s3}, and ABC\cite{abc} are developed on these theories. Although string theory is easily
%undecidable\cite{undecidable_1}\cite{undecidable_2}, the satisfiability problems for string constraints of regular expressions, linear integer arithmetic, and the string length is decidable\cite{theory_BD+23}. There are mainly two strategies for solving string constraints: (1) DPLL(T)-based\cite{dpll_t} string solvers\cite{z3str3}\cite{cvc5} apply heuristic derivation rules to unwind the regular expression gradually and identify several classes of simplification techniques for efficiency. (2) Automata-based string solvers\cite{trau}\cite{z3trau}\cite{ostrich}\cite{atva2020}\cite{BD+23} construct a finite automaton to model the regular expression and use the emptiness problem of the automaton (under linear integer arithmetic) to decide the satisfiability of string constraints. 

\smallskip
\noindent
\emph{Organization.} 
The rest of this paper is structured as follows: Section~\ref{sec:overview} gives an overview of the approach in this paper. Section~\ref{sec:pre} introduces the preliminaries. 
Section~\ref{sec:recl} presents the syntax and semantics of RECL. 
Section~\ref{sec:automaton} defines CEFA. Section~\ref{sec:algorithm} introduces the algorithm to solve RECL constraints. Section~\ref{sec:implementation} shows the experiment results. Section~\ref{sec:conclu} concludes this paper.


%%%%%%%%%%%%%%%%%%%%%%% original texts by Denghang %%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%% original texts by Denghang %%%%%%%%%%%%%%%%%
\hide{
String constraint solving is a subfield of computer science that deals with analyzing and manipulating strings, which are sequences of characters. String constraints solving aim to automatically infer properties of string variables, such as their length, content, and structure, to reason about the behavior of software systems that manipulate strings. It is crucial in security-critical applications, where strings represent sensitive data such as passwords, user input, and network addresses. String constraints solving combines techniques from formal methods, automata theory, and constraint solving and has many applications in areas such as software testing\cite{software_testing_1}\cite{software_testing_2}, program analysis\cite{prog_analysis_1}\cite{prog_analysis_2}\cite{prog_analysis_3}, and malware detection\cite{malware_detection_1}\cite{malware_detection_2}\cite{malware_detection_3_kudzu}. In this context, efficient algorithms and tools for solving string constraints are crucial to improve the security and reliability of modern software systems.\newline
Regular expressions are widely used in programming languages. About 30â€“40 \%
Java, JavaScript, and Python software use regex matching\cite{redos_fse2019}. Bounded repetition is widely used in regex matching\cite{regex_repeat} and is dangerous because Regular expression Denial of Service (ReDoS) may derive from it\cite{redos_lenka}. We have analyzed regular expressions sourced from the Internet\cite{regexlib}\cite{stackoverflow}, among which about 10\% include bounded repetition. Operations like \verb|length| that take string inputs and return an integer frequently appear in real-world JavaScript applications (78\% of string operations in 18 applications\cite{malware_detection_3_kudzu}). These statistics show that a resultful string solver reasoning about regular membership predicate with bounded repetition and \verb|length| operation is required. However, such string constraints may lead to low performance. 
% the state-of-art string solvers (\cite{z3seq}\cite{z3str3}\cite{z3str4}\cite{BD+23}\cite{cvc5}\cite{ostrich}\cite{z3trau}\cite{trau}) lose efficiency. 
For CVC5\cite{cvc5} (which is the winner of QF\_Strings track in SMT-COMP 2022\cite{smt-comp}), the string constraints are solved based on DPLL(T) structure. Each string constraint is seen as a literal boolean and assigned by true or false (Boolean abstraction). CVC5 repeatedly applies derivation rules on these assigned string constraints until the satisfiable solution is found or unsatisfiability is detected. The approach is fast and sound. Nevertheless, it is incomplete because it may not recognize unsatisfiable literals and may not terminate when unrolling regular expression. For example, CVC5 unrolls regular expression $\Sigma_{/a}\{1,300\}$ and $\Sigma^*a\Sigma^*$ when solving the string constraints \ref{eq:cvc5_timeout}. $\Sigma_{/a}\{1,300\}$ repeats a letter excluding $a$ from one time to 300 times. $\Sigma^*a\Sigma^*$ accepts a string containing $a$. It is easy to see that the string constraints are unsat.
However, CVC5 is hard to explore the unsatisfiability, for it can only answer once attempting all strings with lengths less than or equal to 300. The number of the searched string is exponential to the count. We test this instance on CVC5 and get a timeout result when the timeout is set to 60s.
\begin{equation} \label{eq:cvc5_timeout}
  x\in \Sigma_{/a}\{1,300\}\wedge x\in \Sigma^*a\Sigma^*
\end{equation}
Z3Str3\cite{z3str3} is a string solver written on the famous SMT solver Z3\cite{Z3}. It is based on the DPLL(T) structure and uses the same approach as CVC5, except that the derivation rules of Z3 differ from CVC5. Furthermore, Z3str3 exposes the structure of theory literals to the DPLL(T) SAT solver's branching heuristic, resulting in smarter decisions during its search. Z3Str3 can not solve string constraints (\ref{eq:cvc5_timeout}) because the optimization can not avoid the endless unwind of the regular expression. Automata-based methods were proposed to handle the exponential search space of regular expression. One of the automata-based string solver Ostrich\cite{ostrich}\cite{atva2020} encodes string constraints and regular expressions into automata and use the automata theory to solve them. It is sound and complete. But it is inefficient because it is hard to reduce the size of automata. When large counting is constrained on a complex sub-regex, like $ \backslash w \{1, 63\}$ where $\backslash w$ is an English character or a number character, the corresponding automaton in Ostrich becomes very large. It can not be solved within the 60s time limit. The reason is that Ostrich syntactically rewrites the counting operator to the union of finite repeatings of the sub-regex. For example, $\backslash w\{1, 63\}$ is rewritten to $\backslash w\mid\backslash w^2\cdots\mid\backslash w^{63}$ where $\backslash w^i$ means repeat $i\-th$ times on $\backslash w$. The automaton of $\backslash w$ contains $62$ states to accept each possible character, and the automaton of $\backslash w ^i$ contains $62*i$ states. The total number of states in the automaton is $62 + 62*2 + \cdots 62*63=124992$, causing the automaton to be unsolvable in practice. Trau\cite{z3trau}\cite{trau+} is another powerful automata-based solver. It relies on a Counter-Example Guided Abstraction Refinement (CEGAR) framework in which the under- and over-approximation of the automata are iteratively refined. Although it uses simple flat automata to represent regular expressions, it has to build unsolvable automata on regex $\backslash w\{1, 63\}$ as Ostrich because the solution of the flat automata should be within the solution of the original automata. 
Recently, Z3str3 has been extended to BD+23\cite{BD+23} by Berzish et al to handle string constants with regular memberships and length operation effectively. It uses automata to formalize the semantics of regular expressions and applies several length-aware heuristics. BD+23 can avoid building unsolvable automaton because the length abstraction is directly derived from the regex, not the automaton. Unfortunately, the length abstraction is an over-approximation, so it can not solve string constraints (\ref{eq:BD+23_timeout}) whose regular membership predicate contains complementary.
\begin{equation}\label{eq:BD+23_timeout}
  x\in \Sigma_{/a}\{13,13\}\wedge |x| > 13
\end{equation}
To address these issues, we formalize bounded repetition using cost-enriched finite automaton (CEFA)\cite{atva2020} with linear arithmetical constraints. It limits the max(min) run times of some transitions on the accepting run of the automaton, which completely captures the semantics of bounded repetition. The satisfiability problem of string constraints with bounded repetition is reduced to the emptiness problem of cost-enriched finite automata under linear arithmetical constraints (abbreviated as $SAT_{CL}$ problem), which is decidable and can be solved by our previous work \cite{atva2020}. However, the previous work could perform better practically, especially when regular expressions are complex. In this paper, we propose two heuristical methods to improve performance. The first one is under-approximation, which is inspired by Bounded Model Checking \cite{bmc_1}\cite{bmc_2}\cite{bmc_3}. The second one is the symbolic-aware simplification, which is motivated by the observation that the emptiness problem is only related to the symbolic update functions. We implement a powerful string solver OstrichCEA and evaluate it on instances from the real world and other typical benchmarks. The experiment result shows superiority.

\subsubsection{Related Work}
String theories with regular membership predicate and linear length constraints are raised to handle the problems in software verification reasoning about strings and integers. String solvers such as Z3Str3\cite{z3str3}, Z3Seq\cite{z3seq}, BD+23\cite{BD+23}, CVC4\cite{cvc4}, CVC5\cite{cvc5}, (Z3-)Trau\cite{trau}\cite{z3trau}, Ostrich(+)\cite{ostrich}\cite{atva2020}, Sloth\cite{sloth}, S3\cite{s3}, and ABC\cite{abc} are developed on these theories. Although string theory is easily
undecidable\cite{undecidable_1}\cite{undecidable_2}, the satisfiability problems for string constraints of regular expressions, linear integer arithmetic, and the string length is decidable\cite{theory_BD+23}. There are mainly two strategies for solving string constraints: (1) DPLL(T)-based\cite{dpll_t} string solvers\cite{z3str3}\cite{cvc5} apply heuristic derivation rules to unwind the regular expression gradually and identify several classes of simplification techniques for efficiency. (2) Automata-based string solvers\cite{trau}\cite{z3trau}\cite{ostrich}\cite{atva2020}\cite{BD+23} construct a finite automaton to model the regular expression and use the emptiness problem of the automaton (under linear integer arithmetic) to decide the satisfiability of string constraints. 


\subsubsection{Our Contributions}
Our main contributions are as follows:
\begin{enumerate}
  \item  Encode regular expression with bounded repetition into CEFA with linear arithmetical constraints.
  \item  Devise heuristic methods like under-approximation and symbolic-aware simplification to solve the $SAT_{CL}$ problem.
  \item  Generate significant instances with bounded repetition from real-world regular expressions.
  \item  Implement our decision procedure on solver OstrichCEA and compare it with state-of-art string solvers. The result shows the superiority of our encoding and heuristics.
\end{enumerate}

The rest of the paper is structured as follows: Section \ref{sec:pre} introduces the preliminaries. Section \ref{sec:overview} outlines the overall algorithm. Section \ref{sec:automaton} illustrates how to construct an automaton from a regular expression. Section \ref{sec:algorithm} shows how to solve a string constraint with repetition. Section \ref{sec:implementation} presents the experimental results. Section \ref{sec:conclu} concludes the paper and discusses future work.
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\end{document}