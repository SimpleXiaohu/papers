%!TEX root = ../main.tex
%\documentclass{standalone}
%\begin{document}

% Tokens
\subsubsection{Tokens}
A finite \emph{alphabet} $\Sigma$ is the set of all \emph{letters}. A
\emph{string} (or \emph{word}) is a finite sequence of letters from $\Sigma$. $\Sigma^*$ is the set of strings over $\Sigma$. $\epsilon$ is the empty string. $L$ is grammar. A language $\lan(L)$ is a set of words generated by $L$. $\mathbb{N}$ is the set of natural numbers and $\mathbb{Z}$ is the set of integer numbers. We use $a,
  b,\cdots$ to denote the constant letters in $\Sigma$, $u, v,\cdots$ to denote constant
string, $x, y,\cdots$ to denote variable string, $m,n,\cdots$ to
denote integer constant, and $i,j\cdots$ to denote integer variable. For vector, we use $\myvec{v}$ to denote the vector of integer constant, $m_n$ to denote the vector $(m,\cdots, m)$ with length $n$, $\myvec{v}[i]$ to denote the integer value of $\myvec{v}$ at position $i$, $\myvec{v_1}\cdot\myvec{v_2}$ to denote the concatenation of $\myvec{v_1}$ and $\myvec{v_2}$, $R$ to denote the vector of registers, $R_1 \cap R_2$ to denote the same registers in $R_1$ and $R_2$, and $|\myvec{v}|$ or $|R|$ to denote the length of the vector.

\subsubsection{Syntax}
This paper proposes a quantifier-free first-order logic called \textit{Extended String Logic (ESL)}, whose syntax is presented in Table \ref{tab:syntax}. $\varphi$ is a quantifier-free formula that can be a regular membership $x\in\regex$, a quantifier-free Presburger formula $\alpha_1 \leq \alpha_2$, a negation of a formula, or a disjunction of two formulas. $\alpha$ is an integer term which can be an integer constant $m$, integer variable $i$, the length of the string term $|s|$, the minus of an integer term, and the plus of two integer terms. The regular expression $\regex$ is built on empty string $\epsilon$, constant letter $a\in \Sigma$. The supported regex operations involve concatenation $\cdot$, disjunction $+$, intersection $\times$, closure $*$, complement $C$, and bounded repetition $\{m, n\}$. We use $term(\varphi)$ to denote the set of terms and $strvar(\varphi)$ to denote the string variables occurring in $\varphi$. The \emph{literals} of $\varphi$ are $x\in \regex$ and $\alpha_1 \leq \alpha_2$. $x\in \regex$ is called \emph{regular literals} and $\alpha_1 \leq \alpha_2$ is called \emph{linear literals}.
\begin{table}[h]
  \centering
  \begin{tabular}{l r}
    $\varphi$ ::= $x\in \regex \mid \alpha_1\leq\alpha_2 \mid \neg\varphi\mid \varphi\vee\varphi$                                             & formulae            \\
    $\regex$ ::= $\epsilon\mid a\mid \regex\cdot\regex\mid \regex+\regex\mid \regex\times \regex\mid \regex^*\mid\regex^C \mid \regex\{m,n\}$ & regular expressions \\
    $\alpha$ ::= $m \mid i \mid  |s|\mid -\alpha\mid \alpha_1+\alpha_2$                                                                       & integer terms
  \end{tabular}
  \caption{Syntax}\label{tab:syntax}
\end{table}
% Semantic 
\subsubsection{Semantic}
We assume that $S$ is the set of string variables over $\Sigma^*$, and $I$ is the set of integer variables. $\eta: S\times\Sigma\rightarrow\Sigma^*$ is the interpretation on string where $\eta(c)=c$ for every letter $c\in \Sigma$. $\pi: I\rightarrow\mathbb{Z}$ is the interpretation of Presburger arithmetic. Then the semantics is given by a satisfaction relation: $\eta, \pi\models \varphi$ defined in Table \ref{tab:semantics}. We say a formula $\varphi$ is \emph{satisfiable} if a solution $(\eta, \pi)$ exists such as $\eta, \pi\models \varphi$. A formula $\varphi$ is \emph{unsatisfiable} if no solution exists.
\begin{table}[h]
  \centering
  \begin{tabular}{lcl}
    $\eta,\pi \models \varphi_1\vee \varphi_2$ & $\mathsf{iff}$ & $\eta,\pi \models \varphi_1 \text{ or } \eta,\pi \models \varphi_2$ \\
    $\eta,\pi \models \neg\varphi $            & $\mathsf{iff}$ & $\eta,\pi \not\models \varphi$                                      \\
    $\eta, \pi \models x\in \regex$            & $\mathsf{iff}$ & $\exists w \in \lan(\regex),\eta,\pi \models x = w$                 \\
    $\eta, \pi \models \alpha_1 \leq \alpha_2$ & $\mathsf{iff}$ & $\pi(\alpha_1) \leq \pi(\alpha_2) $                                 \\
  \end{tabular}
  \caption{Semantics}
  \label{tab:semantics}
\end{table}
In addition to the classic regex operators (union, concatenation, closure), we syntactically support intersection, complement, and repetition. As we all know, the classic regular language is closed under intersection and complement \cite{aut_hopcraft}. Furthermore, the operation \emph{repetition} $\regex\{m,n\}$ means repeating regex $\regex$ at least $m$ times and at most $n$ times. It can be syntactically rewritten by concatenation and union:
$\regex\{m,n\} \equiv \regex^m\mid\cdots\mid\regex^n$ where $\regex^k$ defines concatenate $\regex$ $k$ times ($m\leq k\leq n$). So the regular language $\lan(\regex)$ defined in Table \ref{tab:syntax} is semantically equal to the classic regular language.

%\end{document}