%!TEX root = ../main.tex
%\documentclass{standalone}
%\begin{document}

\subsubsection{Syntax}
This paper proposes a quantifier-free first-order logic called \textit{Extended String Logic (ESL)}, whose syntax is presented in Table \ref{tab:syntax}. $\varphi$ is a quantifier-free formula that can be a regular membership $x\in\regex$, a quantifier-free Presburger formula $\alpha_1 \leq \alpha_2$, a negation of a formula, or a disjunction of two formulas. $\alpha$ is an integer term which can be an integer constant $m$, integer variable $i$, the length of the string term $|s|$, the minus of an integer term, and the plus of two integer terms. The regular expression $\regex$ is built on empty string $\epsilon$, constant letter $a\in \Sigma$. The supported regex operations involve concatenation $\cdot$, disjunction $+$, intersection $\times$, closure $*$, complement $C$, and bounded repetition $\{m, n\}$. We use $term(\varphi)$ to denote the set of terms and $strvar(\varphi)$ to denote the string variables occurring in $\varphi$. The \emph{literals} of $\varphi$ are $x\in \regex$ and $\alpha_1 \leq \alpha_2$. $x\in \regex$ is called \emph{regular literals} and $\alpha_1 \leq \alpha_2$ is called \emph{linear literals}.
\begin{table}[h]
  \centering
  \begin{tabular}{l r}
    $\varphi$ ::= $x\in \regex \mid \alpha_1\leq\alpha_2 \mid \neg\varphi\mid \varphi\vee\varphi$                                             & formulae            \\
    $\regex$ ::= $\epsilon \mid a \mid \regex\cdot\regex \mid \regex+\regex \mid \regex^* \mid \regex \cap \regex \mid \regex^C \mid \regex \setminus \regex \mid \regex^{\{m,n\}}$ & regular expressions \\
    $\alpha$ ::= $m \mid i \mid  |s|\mid -\alpha\mid \alpha_1+\alpha_2$                                                                       & integer terms
  \end{tabular}
  \caption{Syntax}\label{tab:syntax}
\end{table}
% Semantic 
\subsubsection{Semantic}
We assume that $S$ is the set of string variables over $\Sigma^*$, and $I$ is the set of integer variables. $\eta: S\times\Sigma\rightarrow\Sigma^*$ is the interpretation on string where $\eta(c)=c$ for every letter $c\in \Sigma$. $\pi: I\rightarrow\mathbb{Z}$ is the interpretation of Presburger arithmetic. Then the semantics is given by a satisfaction relation: $\eta, \pi\models \varphi$ defined in Table \ref{tab:semantics}. We say a formula $\varphi$ is \emph{satisfiable} if a solution $(\eta, \pi)$ exists such as $\eta, \pi\models \varphi$. A formula $\varphi$ is \emph{unsatisfiable} if no solution exists.
\begin{table}[h]
  \centering
  \begin{tabular}{lcl}
    $\eta,\pi \models \varphi_1\vee \varphi_2$ & $\mathsf{iff}$ & $\eta,\pi \models \varphi_1 \text{ or } \eta,\pi \models \varphi_2$ \\
    $\eta,\pi \models \neg\varphi $            & $\mathsf{iff}$ & $\eta,\pi \not\models \varphi$                                      \\
    $\eta, \pi \models x\in \regex$            & $\mathsf{iff}$ & $\exists w \in \lan(\regex),\eta,\pi \models x = w$                 \\
    $\eta, \pi \models \alpha_1 \leq \alpha_2$ & $\mathsf{iff}$ & $\pi(\alpha_1) \leq \pi(\alpha_2) $                                 \\
  \end{tabular}
  \caption{Semantics}
  \label{tab:semantics}
\end{table}
In addition to the classic regex operators (union, concatenation, closure), we syntactically support intersection, complement, and repetition. As we all know, the classic regular language is closed under intersection and complement \cite{aut_hopcraft}. Furthermore, the operation \emph{repetition} $\regex\{m,n\}$ means repeating regex $\regex$ at least $m$ times and at most $n$ times. It can be syntactically rewritten by concatenation and union:
$\regex\{m,n\} \equiv \regex^m\mid\cdots\mid\regex^n$ where $\regex^k$ defines concatenate $\regex$ $k$ times ($m\leq k\leq n$). So the regular language $\lan(\regex)$ defined in Table \ref{tab:syntax} is semantically equal to the classic regular language.

%\end{document}