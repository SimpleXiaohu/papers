%!TEX root = ../main.tex
%\documentclass{standalone}
%\begin{document}

%\subsubsection{Syntax}
In the sequel, we define string constraints with regex-counting and string-length function (abbreviated as RECL). The syntax of RECL is defined by the rules in Figure~\ref{fig:syntax}, where $x$ is a string variable, $i$ is an integer variable, $a$ is a character from an alphabet $\Sigma$, and $m, n$ are integer constants. 
A RECL formula $\varphi$ is a conjunction of atomic formulas of the form $x \in \regex$, $x \not \in \regex$, or $t_1\ \op\ t_2$, where $\regex$ is a regular expression,  
$t_1$ and $t_2$ are integer terms, and $\op \in \{=, \neq, \le, \ge, <, >\}$. Atomic formulas of the form $x \in \regex$ or $x \not \in \regex$ are called \emph{regular membership} constraints and atomic formulas of the form $t_1\ \op\ t_2$ are called \emph{length} constraints. 
%
A regular expression $\regex$ is built from $\emptyset$, the empty string $\epsilon$, and characters $a$ by using concatenation  $\cdot$, alternation $+$, Kleene star $^*$, intersection $\cap$, complement $\bar{\mbox{ }}$, difference $\setminus$, counting $^{\{m,n\}}$ or $^{\{m,\infty\}}$. An integer term is is built from constants $n$, variables $i$, and string lengths $|x|$, by operators $+$ and $-$.
% 
%is a quantifier-free formula that can be a regular membership $x\in\regex$, a quantifier-free Presburger formula $\alpha_1 \leq \alpha_2$, a negation of a formula, or a disjunction of two formulas. $\alpha$ is an integer term which can be an integer constant $m$, integer variable $i$, the length of the string term $|s|$, the minus of an integer term, and the plus of two integer terms. The regular expression $\regex$ is built on empty string $\epsilon$, constant letter $a\in \Sigma$. The supported regex operations involve concatenation $\cdot$, disjunction $+$, intersection $\times$, closure $*$, complement $C$, and bounded repetition $\{m, n\}$. We use $term(\varphi)$ to denote the set of terms and $strvar(\varphi)$ to denote the string variables occurring in $\varphi$. The \emph{literals} of $\varphi$ are $x\in \regex$ and $\alpha_1 \leq \alpha_2$. $x\in \regex$ is called \emph{regular literals} and $\alpha_1 \leq \alpha_2$ is called \emph{linear literals}.
\begin{figure}[h]
  \centering
%  \begin{tabular}{l r}
$ \begin{array}{l l l r}
    \varphi & ::= & x\in \regex \mid x \not \in \regex \mid t_1\  \op\ t_2 \mid  \varphi \wedge \varphi                                              & \mbox{formulas}            \\
    \regex &::= & \emptyset \mid \epsilon \mid a \mid \regex\cdot \regex \mid \regex+\regex \mid \regex^* \mid \regex \cap \regex \mid \overline{\regex} \mid \regex \setminus \regex \mid \regex^{\{m,n\}} \mid \regex^{\{m,\infty\}} \mid (e) & \mbox{regexes} \\
    t &::= & n \mid i \mid  |x| \mid t - t \mid t + t                                                                    & \mbox{integer terms}
    \end{array}
  $
%  \end{tabular}
  \caption{Syntax of RECL }\label{fig:syntax}
\end{figure}
Moreover, for $S \subseteq \Sigma$ with $S = \{a_1, \cdots, a_k\}$, we use $S$ as an abbreviation of $a_1 + \cdots + a_k$.

\zhilin{stopped here}

%\subsubsection{Semantic}

We assume that $S$ is the set of string variables over $\Sigma^*$, and $I$ is the set of integer variables. $\eta: S\times\Sigma\rightarrow\Sigma^*$ is the interpretation on string where $\eta(c)=c$ for every letter $c\in \Sigma$. $\pi: I\rightarrow\mathbb{Z}$ is the interpretation of Presburger arithmetic. Then the semantics is given by a satisfaction relation: $\eta, \pi\models \varphi$ defined in Table \ref{tab:semantics}. We say a formula $\varphi$ is \emph{satisfiable} if a solution $(\eta, \pi)$ exists such as $\eta, \pi\models \varphi$. A formula $\varphi$ is \emph{unsatisfiable} if no solution exists.
\begin{table}[h]
  \centering
  \begin{tabular}{lcl}
    $\eta,\pi \models \varphi_1\vee \varphi_2$ & $\mathsf{iff}$ & $\eta,\pi \models \varphi_1 \text{ or } \eta,\pi \models \varphi_2$ \\
    $\eta,\pi \models \neg\varphi $            & $\mathsf{iff}$ & $\eta,\pi \not\models \varphi$                                      \\
    $\eta, \pi \models x\in \regex$            & $\mathsf{iff}$ & $\exists w \in \lan(\regex),\eta,\pi \models x = w$                 \\
    $\eta, \pi \models \alpha_1 \leq \alpha_2$ & $\mathsf{iff}$ & $\pi(\alpha_1) \leq \pi(\alpha_2) $                                 \\
  \end{tabular}
  \caption{Semantics}
  \label{tab:semantics}
\end{table}
In addition to the classic regex operators (union, concatenation, closure), we syntactically support intersection, complement, and repetition. As we all know, the classic regular language is closed under intersection and complement \cite{aut_hopcraft}. Furthermore, the operation \emph{repetition} $\regex\{m,n\}$ means repeating regex $\regex$ at least $m$ times and at most $n$ times. It can be syntactically rewritten by concatenation and union:
$\regex\{m,n\} \equiv \regex^m\mid\cdots\mid\regex^n$ where $\regex^k$ defines concatenate $\regex$ $k$ times ($m\leq k\leq n$). So the regular language $\lan(\regex)$ defined in Table \ref{tab:syntax} is semantically equal to the classic regular language.

%\end{document}