%!TEX root = ../main.tex
%\documentclass{standalone}
%\begin{document}

As mentioned in Section \ref{sec:overview}, the main idea of our approach is to model the counting operators symbolically by registers, instead of unfolding them explicitly. Additionally, we use registers to represent string lengths. After that, the satisfiability of string constraints involve regex-counting and string-length is reduced to the satisfiability of LIA, which can be solved by off-the-shelf SMT solvers. We also propose techniques to reduce automata sizes and utilize under approximations to enhance performance.
\subsection{Encode Regex with Counting to CEFA} \label{subsec:regex2cefa}
The most important point of our approach is encoding counting operators by registers rather than explicitly unfolding them. In this section, we discuss the encoding in detail. A counting operator is called \emph{handled} if it is not the sub-regex of complement, closure or other counting, and called \emph{unhandled} otherwise. For example, $(\Sigma \setminus a)^{\{m,n\}}$ is handled, while $((\Sigma \setminus a)^{\{m,n\}})^*$ is unhandled. We first discuss the encoding of handled counting operators, and then discuss the encoding of unhandled counting operators.

% We must syntactically rewrite bounded repetition $\regex\{m,n\}$ if it is the sub-regex of complement (e.g., $(\regex\{m,n\})^C$), closure(e.g., $(\regex\{m,n\})^*$), and bounded repetition(e.g., $(\regex\{m,n\})\{m', n'\}$), we unwind it to $\regex^m\mid\cdots\mid\regex^n$. After this syntactic rewriting, we call the resulting regex $\regex'$ \emph{non-nested}.
Given a regex $\regex$ without unhandled counting operator, the base case is constructing CEFA of a single character, an empty string, or an empty language. The inductive step is constructing CEFA of the concatenation, union, intersection, closure, complement and counting of CEFA(s) of sub-regex(es). Operations except for counting are trivial and represented in Appendix , we only illustrate counting here.

Given a regex $\regex^{\{m,n\}}$ without unhandled counting operator, suppose the NFA recognizing $\regex$ is $\aut = (Q,\Sigma,\delta,q_I,F)$, then the CEFA recognizing $\regex^{\{m,n\}}$ is defined as $\aut_{m,n} = (Q, \Sigma, \delta',q_I, F\cup\{q_I\}, r, \theta)$ where:
\begin{itemize}
  \item $q_I$ is set to accepting state,
  \item $r$ is a new register,
  \item $\delta'$ is composed by transition $q\xrightarrow[(0)]{a} q'$ for each transition $q\xrightarrow[()]{a} q' \in \delta$, and transition $q_f\xrightarrow[(1)]{\epsilon} q_I$ for each accepting state $q_f\in F$,
  \item $\theta$ is the function mapping each accepting state to a same linear integer arithmetic $(m\leq )r\leq n$. The lower bound $m\leq r$ is unnecessary if $q_I\in F$.
\end{itemize}
The main idea is to add an epsilon transition to initial state from each accepting state like closure, to repeat the sub-regex. Then the counting time is incremented by 1 when the epsilon transition is invoked. Details are illustrated in Fig.\ref{fig:construct_repetition}. A new register $r$ is added to store the counting times. The transition $q\xrightarrow[(1)]{\epsilon} q_I$ it constructed to increment the counting times. The accepting condition $(m\leq) r\leq n$ is attached to each accepting state to constrain the counting times of the accepting word. After the construction, we need to eliminate epsilon transitions. It is done by adding transition $q_f\xrightarrow[(1)]{a} q$ for transition $q_I\xrightarrow[(0)]{a} q$ and then deleting the transition $q_f\xrightarrow[(1)]{\epsilon} q_I$, for each accepting state $q_f$.

\begin{figure}[h]
  \begin{subfigure}[b]{0.49\textwidth}
    \centering
    \begin{tikzpicture}[
      shorten >=1pt,node distance=2cm,on grid,>={Stealth[round]},
      initial text=, every state/.style={minimum size = 0.001cm},
      ]

      \node[state,initial]            (q_0)                      {};
      \node[state, accepting]         (q_1) [right=of q_0]       {};
      \node [fit=(q_0) (q_1)] {$\cdots$};
    \end{tikzpicture}
    \caption{The NFA recognizing $\regex$}
  \end{subfigure}
  \begin{subfigure}[b]{0.49\textwidth}
    \centering
    \begin{tikzpicture}[
      shorten >=1pt,node distance=2cm,on grid,>={Stealth[round]},
      initial text=, every state/.style={minimum size = 0.001cm},
      accepting text=
      ]

      \node at (-0.5,0.5) {$\scriptstyle (\myemph{m}\leq) r\leq \myemph{n}$};
      \node[state,initial,accepting]            (q_0)                      {};
      \node[state, accepting]         (q_1) [right=of q_0]       {};
      \path[->] (q_1) edge[bend right]   node    [above] {\myemph{$\scriptstyle \mathbf{\epsilon:(1)}$}} (q_0);
      \node [fit=(q_0) (q_1)] {$\cdots$};
    \end{tikzpicture}
    \caption{The CEFA recognizing $\regex^{\{m,n\}}$}
  \end{subfigure}
  \caption{The construction of counting operator}
  \label{fig:construct_repetition}
\end{figure}
\begin{example}
  To construct the CEFA recognizing $(\Sigma\setminus a)\{5,60\}$ with alphabet $\Sigma = \{a,b,c\}$. As shown in Fig.\ref{subfig:count_aut_sigma_minus_a_5_60}, the base cases are the constructions of character $b$ (Fig.\ref{subfig:count_aut_b}) and $c$ (Fig.\ref{subfig:count_aut_c}). The first inductive step is construction the union of them (Fig.\ref{sub@subfig:count_aut_sigma_minus_a}). The second inductive step is to add counting information on the automaton. To do that we add a new register $r$ to save counting times,  transitions $q_2\xrightarrow[(1)]{\epsilon} q_0$ and $q_1\xrightarrow[(1)]{\epsilon} q_0$  to update the counting times. The accepting condition of each accepting state is $5\leq r\leq 60$, which ensure the counting time of the accepting word is in the range $[5,60]$. After epsilon elimination we get the CEFA recognizing $(\Sigma\setminus a)\{5,60\}$ (shown in Fig.\ref{subfig:count_aut_sigma_minus_a_5_60}).
  \begin{figure}[h]
    \begin{subfigure}[b]{0.49\textwidth}
      \centering
      \begin{tikzpicture}[
        shorten >=1pt,node distance=2cm,on grid,>={Stealth[round]},
        initial text=, every state/.style={minimum size = 0.001cm},
        ]
        \node[state,initial]            (q_0)                      {$\scriptstyle q_0$};
        \node[state,accepting]                    (q_1) [right=of q_0]       {$\scriptstyle q_1$};

        \path[->] (q_0) edge              node      [above]           {$\scriptstyle b:()$} (q_1);
      \end{tikzpicture}
      \caption{The NFA recognizing $b$}
      \label{subfig:count_aut_b}
    \end{subfigure}
    \begin{subfigure}[b]{0.49\textwidth}
      \centering
      \begin{tikzpicture}[
        shorten >=1pt,node distance=2cm,on grid,>={Stealth[round]},
        initial text=, every state/.style={minimum size = 0.001cm},
        ]
        \node[state,initial]            (q_0)                      {$\scriptstyle q_0$};
        \node[state,accepting]                    (q_1) [right=of q_0]       {$\scriptstyle q_2$};

        \path[->] (q_0) edge              node      [above]           {$\scriptstyle c:()$} (q_1);
      \end{tikzpicture}
      \caption{The NFA recognizing $c$}
      \label{subfig:count_aut_c}
    \end{subfigure}
    \begin{subfigure}[b]{0.49\textwidth}
      \centering
      \begin{tikzpicture}[
        shorten >=1pt,node distance=1cm,on grid,>={Stealth[round]},
        initial text=, every state/.style={minimum size = 0.001cm},
        ]
        \node[state,initial]      (q_0)                      {$\scriptstyle q_0$};
        \node (q_tmp) [right=of q_0]       {};
        \node[state, accepting]   (q_1) [above=of q_tmp]       {$\scriptstyle q_1$};
        \node[state, accepting]   (q_2) [below=of q_tmp]       {$\scriptstyle q_2$};

        \path[->] (q_0) edge node [right] {$\scriptstyle b:()$} (q_1)
        (q_0) edge           node [right] {$\scriptstyle c:()$} (q_2);
      \end{tikzpicture}
      \caption{The NFA recognizing $\Sigma \setminus a$}
      \label{subfig:count_aut_sigma_minus_a}
    \end{subfigure}
    \begin{subfigure}[b]{0.49\textwidth}
      \centering
      \begin{tikzpicture}[
        shorten >=1pt,node distance=1cm,on grid,>={Stealth[round]},
        initial text=, every state/.style={minimum size = 0.005cm},
        ]
        \node at (-1, 1) {$\scriptstyle \myemph{5}\leq r \leq \myemph{60}$};
        \node[state,initial, accepting]      (q_0)                      {$\scriptstyle q_0$};
        \node (q_tmp) [right=of q_0]       {};
        \node[state, accepting]   (q_1) [above=of q_tmp]       {$\scriptstyle q_1$};
        \node[state, accepting]   (q_2) [below=of q_tmp]       {$\scriptstyle q_2$};

        \path[->] (q_0) edge node [right] {$\scriptstyle b:(0)$} (q_1)
        (q_1) edge [loop right] node {$\scriptstyle b:(\myemph{1})$} (q_1)
        (q_0) edge           node [right] {$\scriptstyle c:(0)$} (q_2)
        (q_2) edge [loop right] node {$\scriptstyle c:(\myemph{1})$} (q_0);
      \end{tikzpicture}
      \caption{The CEFA recognizing $(\Sigma\setminus a)\{\myemph{5},\myemph{60}\}$}
      \label{subfig:count_aut_sigma_minus_a_5_60}
    \end{subfigure}
    \caption{The example of constructing regex with counting}
  \end{figure}
\end{example}

Above discusses the construction of handled counting operators. The unhandled counting operator can not be constructed by the same way. For example, for the regex $(ab^{\{1,100\}})*$ with unhandled counting operator, there are infinite repetitions of $ab^{\{1,100\}}$. The counting times of each repetition are irrelevant, so that we can not represent them using finite registers. We have to syntactically rewrite the unhandled counting operator into union operator and concatenation operator. More exactly, the sub-regex $\regex^{\{m,n\}}$ in the unhandled regex is rewritten into $\underbrace{\regex\cdot\regex\cdots\regex}_{m \text{ times}}\mid\cdots\mid \underbrace{\regex\cdot\regex\cdots\regex}_{n \text{ times}}$.
% Based on the decision procedure defined in the paper \cite{atva2020}, we propose an efficient algorithm to solve ESL formula $\varphi\wedge \psi$ where $\varphi$ is the conjunction of literals and $\psi$ is the conjunction of linear literals without length operation. For each string variable $x$, we first compute pre-images of all linear literal $i=|x|$. Then we generate CEFAs of all regular expressions $\regex$ in all regular literals $x\in \regex$ and intersect these CEFAs and pre-images to get the final automaton $\aut_x$ for $x$. At present, there is a final CEFA for each string variable $x$. The linear arithmetic constraint $\psi$ restricts the accepting word of final CEFAs. Thus the satisfiability problem is the emptiness checking problem of final CEFAs under $\psi$. If it is empty, the string constraints are unsatisfiable. Otherwise, the string constraints are satisfiable.
% The emptiness checking problem of CEFAs under linear integer arithmetic is theoretically pspace-complete\cite{atva2020}. To solve it efficiently for a practical example, we develop heuristic ways such as under-approximation (Section \ref{subsec:under-approx}) and symbolic-aware simplification (Section \ref{subsec:simplify}).
\subsection{Handling of String-length}
Given a string-length constraint, we build a CEFA with a register storing the word length. Namely, the CEFA is $(\{q_I\}, \Sigma, \{q_I\xrightarrow[(1)]{\Sigma} q_I\}, q_I, \{q_I\}, r, \theta)$ where accpeting condition $\theta$ is based on the length formula. As an illustration, example \ref{eg:pre_len} shows the CEFA of length constraints $|x| > 120$, whose language is the set of all words with length greater than $120$. The simple loop $q_I\xrightarrow[(1)]{\Sigma} q_I$ increase $1$ on register $r$ for all char in $\Sigma$, so that the value of $r$ is equal to the length of word. The accepting condition $\theta$ attachs $q_I$ to $r > 120$, ensuring the length of accepting word is greater than $120$.

% The formal definition of pre-images of abundant string functions is listed in \cite{atva2020}, and we do not repeat it here.
\begin{example}[The CEFA of $|x| > 120$]\label{eg:pre_len} 
  \begin{figure}[h]
    \centering
    \begin{tikzpicture}[
      shorten >=1pt,node distance=2cm,on grid,>={Stealth[round]},
      initial text=, every state/.style={minimum size = 0.001cm},
      ]

      \node at (-0.5, 0.5) {$\scriptstyle r > 120$};
      \node[state,initial,accepting]            (q_0)       {$\scriptstyle q_I$};

      \path[->] (q_0) edge [loop below] node{$\scriptstyle\Sigma:(1)$} ();
    \end{tikzpicture}
  \end{figure}
\end{example} 
% \subsection{Combine Regex-counting and String-length}
% In the previous section, we have discussed the construction of regex-counting operator and string-length constraint. In this section, we show how to combine them to deal with the string constraints with regex-counting and string-length. 
% \begin{definition} [The Product of Two CEFA]

%   Given two CEFAs $\aut_1 = (Q_1, \Sigma, \delta_1, q_{I_1}, F_1, R_1, \theta_1)$ and $\aut_2 = (Q_2, \Sigma, \delta_2, q_{I_2}, F_2, R_2, \theta_2)$ with $R_1\cap R_2 = \emptyset$, the product of them, denoted by $\aut_1 \times \aut_2$, is defined as $(Q_1\times Q_2, \Sigma, \delta, (q_{I_1}, q_{I_2}), F_1\times F_2, R_1\cup R_2, \theta)$ where
%   \begin{itemize}
%     \item $\delta$ comprises the tuples $((q_1, q_2), a, (q_1', q_2'), \myvec{v_1}\cdot \myvec{v_2})$ such that $(q_1, a, q_1', \myvec{v_1})\in \delta_1$ and $(q_2, a, q_2', \myvec{v_2})\in \delta_2$.
%     \item $\theta((q_1, q_2))$ is $\theta_1(q_1)\wedge \theta_2(q_2)$ for each accepting state $(q_1, q_2)\in F_1\times F_2$.
%   \end{itemize}
% \end{definition}
% With the help of product, we can combine the CEFAs of regex-counting and string-length. For example, the CEFA of $x$ in the string constraints $x \in (\Sigma \setminus a)^{\{5, 60\}} (\Sigma \setminus b)^{\{5, 60\}} (\Sigma \setminus c)^{\{0, 60\}} \wedge x \in \Sigma^* c \wedge |x| > 120$ is the product of the CEFA of regex $(\Sigma \setminus a)^{\{5, 60\}} (\Sigma \setminus b)^{\{5, 60\}} (\Sigma \setminus c)^{\{0, 60\}}$, the CEFA of regex $\Sigma^*$ and the CEFA of length constraints $|x| > 120$.

\subsection{Emptiness Checking Problem on CEFAs} \label{subsec:emptiness}
After encoding counting operator and length constraint to CEFAs, there are only automaton memberships $x\in \aut$ and LIA formula $t_1 \ \op \ t_2$ where $\aut$ is CEFA and $t_1, t_2$ are integer terms. Let $\psi$ denotes the conjunction of all LIA formulae $t_1\ \op\ t_2$ and $\Lambda_x = \{\aut_x^1, \aut_x^2,\cdots \aut_x^n\}$ denotes the set of CEFAs in the automaton membership $x\in \aut$. The emptiness checking problem of $\Lambda_x$ under $\psi$ is the problem that checks whether there exists a word $w$ such that $w\in \aut_x^1, w\in \aut_x^2\cdots w\in \aut_x^n$ and $\psi[\myvec{V}/\myvec{r}]$ holds, where $\myvec{r}$ are all registers and $\myvec{V}$ are corresponding register values in automata of $\Lambda_x$ after running $w$. The emptiness problem is \emph{abbreviated as $SAT_{CEFA}[LIA]$ problem}. 

As mentioned in \cite{atva2020}, the \emptinessprob{} is theoretically Pspace-complete. We has used a model-checking tool \emph{nuXmv}\cite{nuxmv} to solve it in previous work. However, it is not efficient enough for complex string constraints. So we put forward a new framework that brings in symbolic-aware simplification and under-approximation heuristics.

The main idea of our framework is to simplify the input CEFAs firstly and under-approximate the solution of the \emptinessprob{} by adding length bounds on string variables. If the under-approximation is satisfiable, the CEFAs are not empty under $\psi$. Otherwise, we check the Parikh image of the simplified CEFAs. If the Parikh image is satisfiable, the CEFAs are not empty under $\psi$. Or else, they are empty. The framework is \emph{sound} and \emph{complete}.

The framework is shown in Algorithm \ref{alg:emptiness}, we simplify the input CEFAs at line 1 because they may have too many transitions and registers to solve. The main idea of the simplification is treating the alphabet as unary and the symbolic updates as characters of transitions in the minimization. After the simplification, we try to find a solution by under-approximation at line 2 and line 3. The under-approximation algorithm explore possible satisfiable register values within a length bound $MaxBound$. If it finds a solution then we return true because the under-approximation is sound for sat. Otherwise, we compute the Parikh images of the simplified CEFAs and check if the Parikh images are satisfiable in conjunction with $\psi$ at line 12. The Parikh image checking is complete so that satisfiability implies non-emptiness directly. 

The under-approximation program is incremental. In other words, it tries to find a solution with smaller length bound of each string variable first and increment the string length bound if the search of smaller length bound fails. $MaxBound$ is the max length bound we try which is empirically set to $15$ in our experiment. It should not be too large because of the exponential growth of searching space. The details of simplification and under-approximation are shown in Algorithm \ref{alg:simplify} and the details of  are shown in Algorithm \ref{alg:underApprox}.

\begin{algorithm}[h]
  \caption{ $\algfun{nonEmpty}(auts, \psi)$}
  \label{alg:emptiness}
  \begin{algorithmic}[1]
    \Require the CEFAs $auts$ and the linear integer arithmetic $\psi$
    \Ensure $true$ or $false$
    \Statex
    \State $simpliAuts \leftarrow \algfun{simplify}(auts)$
    % \For{$bound \gets 1, MaxBound$ }
    % \State $\varphi_{under}\gets \algfun{underApprox}(simpliAuts, bound)$
    % \If{$\varphi_{under}\wedge \psi$ is sat}
    % \State \textbf{return} $true$
    % \EndIf
    % \EndFor
    \If{\algfun{underApproxSolve}($simpliAuts, \psi, MaxBound$) is true}
    \State \textbf{return} $true$
    \EndIf
    \State $\varphi \gets \algfun{parikhImage}(simpliAuts)$
    \If{$\varphi\wedge \psi$ is sat}
    \State \textbf{return} $true$
    \Else
    \State \textbf{return} $false$
    \EndIf
  \end{algorithmic}
\end{algorithm}
\subsubsection{Symbolic-Aware Simplification} \label{subsec:simplify}
The purpose of simplification is to remove duplicated transitions and registers. In the emptiness checking Algorithm \ref{alg:emptiness}, the non-emptiness is equal to the reachability of CEFAs. Thus, the symbolic updates on transitions are meritorious because it influences registers values, while the characters are not. The alphabet of the CEFA can be seen as unary (i.e., the alphabet is $\{a\}$) and the vectors as characters. The special vector $\myvec{0}_n$ with only zero elements is seen as $\epsilon$ character. Namely, given a CEFA $\aut = (Q, \Sigma, \delta, q_I, F, R, \theta)$, we obtain a symbolic form  $\aut_{sym} = (Q, \Sigma', \delta', q_I, F, R, \theta)$ where
\begin{itemize}
  \item $\Sigma' = \{a\}$,
  \item the transition set $\delta'$ is composed of transition $q\xrightarrow[\myvec{v}]{a}q'$ if there is a transition $q\xrightarrow[\myvec{v}]{b} q'$ in $\delta$ for $b\in \Sigma$.
\end{itemize}

 For the symbolic form $\aut_{sym}$, we treat $q\xrightarrow[\myvec{0}_n]{a}q'$ as epsilon transition and compute the epsilon-closure based on it. Likewise, we treat $q\xrightarrow[\myvec{v}]{a}q'$ as a transition with character $(a, \myvec{v})$ and determine the automaton based on it. Two accepting states are equivalent if they have the same accepting condition, and two states are equivalent if they reach equivalent states for each character. We simplify the automaton by merging these equivalent states. Briefly, we directly apply algorithms of epsilon-closure, determination, and simplification in \cite{aut_hopcraft}.
The explanation above discuss funcitons $\algfun{determinizeByVec}$ and $\algfun{minimizeByVec}$ at line 3 and line 4. From line 5 to line 13, we check whether two registers $r_i$ and $r_j$ are duplicated. (i.e., the symbolic updates of them are always the same). If them are duplicated at line 6, we remove one of them at line 7 and the corresponding symbolic update at line 9. After deleting the duplicated registers, we add constraint $r_i = r_j$ to store the value of the deleted register, to ensure the value of it is consistent at line 11.

We have the following proposition:
\begin{proposition}
  Given a set of CEFAs $\Lambda=\{\aut_1, \cdots, \aut_2\}$ and arbitrary LIA $\psi$, the emptiness of $\Lambda$ on $\psi$ is equal to the emptiness of $\algfun{simplify}(\Lambda)$ on $\psi$.
\end{proposition}
\begin{algorithm}[h]
  \caption{$\algfun{simplify}(auts)$}
  \label{alg:simplify}
  \begin{algorithmic}[1]
    \Require A set of CEFAs
    \Ensure The simplified CEFAs
    \Statex
    \For{$\aut \in auts$}
    \State Suppose that $\aut = (Q, \Sigma, \delta, q_I, F,
      R, \theta)$ and $R=(r_1,\cdots, r_n)$
    \State $\algfun{determinizeByVec}(\aut)$
    \State $\algfun{minimizeByVec}(\aut)$
    \ForAll{$(i, j)$ where $1\leq i \leq j \leq n$}
    \If {$\myvec{v}[i] = \myvec{v}[j]$ for every vector $\myvec{v}\in \aut$ }
    \State $R\gets(\cdots r_{j-1}r_{j+1}\cdots)$ \Comment remove $r_j$ from the register vector $R$
    \ForAll{$\myvec{v'}\in \aut$}
    \State $\myvec{v'}\gets(\cdots\myvec{v'}[j-1]\myvec{v'}[j+1]\cdots)$ \Comment remove $\myvec{v'}[j]$ from each vector $\myvec{v'}$
    \EndFor
    \State $\theta \gets\theta\wedge r_i = r_j$
    \EndIf
    \EndFor
    \EndFor
    \State \textbf{return} $auts$
  \end{algorithmic}
\end{algorithm}
\begin{example}
  Considering the CEFA (Fig.\ref{subfig:count_aut_sigma_minus_a_5_60}) recognizing $(\Sigma\setminus a)\{5,60\}$ where $\Sigma = \{a,b,c\}$. We first obtain a symbolic form of it by using unary alphabet (Fig.\ref{subfig:sigma_minus_a_5_60:simplify}) and then minimize the symbolic form based on the label $"a:(1)"$(Fig.\ref{subfig:simp_final}).
  \begin{figure}[h]
    \begin{subfigure}[b]{0.49\textwidth}
      \centering
      \begin{tikzpicture}[
        shorten >=1pt,node distance=1cm,on grid,>={Stealth[round]},
        initial text=, every state/.style={minimum size = 0.005cm},
        ]
        \node at (-1, 1) {$\scriptstyle 5\leq r \leq 60$};
        \node[state,initial, accepting]      (q_0)                      {$\scriptstyle q_0$};
        \node (q_tmp) [right=of q_0]       {};
        \node[state, accepting]   (q_1) [above=of q_tmp]       {$\scriptstyle q_1$};
        \node[state, accepting]   (q_2) [below=of q_tmp]       {$\scriptstyle q_2$};

        \path[->] (q_0) edge node [right] {$\scriptstyle a:(0)$} (q_1)
        (q_1) edge [loop right] node {$\scriptstyle a:(1)$} (q_1)
        (q_0) edge           node [right] {$\scriptstyle a:(0)$} (q_2)
        (q_2) edge [loop right] node {$\scriptstyle a:(1)$} (q_0);
      \end{tikzpicture}
      \caption{The symbolic form of $\aut_{\Sigma\setminus a\{5,60\}}$}
      \label{subfig:sigma_minus_a_5_60:simplify}
    \end{subfigure}
    \begin{subfigure}[b]{0.49\textwidth}
      \centering
      \begin{tikzpicture}[
        shorten >=1pt,node distance=1cm,on grid,>={Stealth[round]},
        initial text=, every state/.style={minimum size = 0.001cm},
        ]

        \node at (-0.5, 0.5) {$\scriptstyle 5\leq r \leq 60$};
        \node[state,initial,accepting]            (q_0)       {$\scriptstyle q_I$};
  
        \path[->] (q_0) edge [loop below] node{$\scriptstyle a:(1)$} ();
      \end{tikzpicture}
      \caption{Simplify the CEFA based on symbolic label}
      \label{subfig:simp_final}
    \end{subfigure}
    \caption{Symbolic simplification removes duplicated transitions and states.}
    \label{fig:simplification_example}
  \end{figure}

\end{example}
\begin{example}
  Considering the string constraints $i=|x|\wedge j=|x|$. We compute the CEFAs of $i=|x|$, $j=|x|$ and intersect them to get the final CEFA represented in Fig.\ref{subfig:duplicate}. However, the register $r_1$ and $r_2$ in the final CEFA are duplicated since their symbolic updates are always same. We simplify the CEFA by removing the duplicated register $r_2$ and corresponding symbolic updates, as shown in Fig.\ref{subfig:remove_duplicate}. To maintain the value of $r_2$, we add a constraint $r_2=r_1$ in the accepting condition.
  \begin{figure}[h]
    \begin{subfigure}[b]{0.49\textwidth}
      \centering
      \begin{tikzpicture}[
        shorten >=1pt,node distance=1cm,on grid,>={Stealth[round]},
        initial text=, every state/.style={minimum size = 0.001cm},
        accepting text=${\scriptstyle i=r_1\wedge j=r_2 }$, accepting/.style=accepting by arrow,
        ]
        \node at (-0.5,0.5) {$R=(r_1, \myemph{r_2})$};
        \node[state,initial,accepting]            (q_0)       {};

        \path[->] (q_0) edge [loop below] node{$\scriptstyle\Sigma:(1,\myemph{1})$} ();
      \end{tikzpicture}
      \caption{An automaton with duplicated registers}
      \label{subfig:duplicate}
    \end{subfigure}
    \begin{subfigure}[b]{0.49\textwidth}
      \centering
      \begin{tikzpicture}[
        shorten >=1pt,node distance=1cm,on grid,>={Stealth[round]},
        initial text=, every state/.style={minimum size = 0.001cm},
        accepting text=${\scriptstyle i=r_1\wedge j=r_2\wedge \myemph{r_1 = r_2} }$, accepting/.style=accepting by arrow,
        ]

        \node at (-0.5,0.5) {$R=(r_1)$};
        \node[state,initial,accepting]            (q_0)       {};

        \path[->] (q_0) edge [loop below] node{$\scriptstyle\Sigma$/(1)} ();
      \end{tikzpicture}
      \caption{Remove the duplicated registers and corresponding symbolic updates}
      \label{subfig:remove_duplicate}
    \end{subfigure}
    \caption{Symbolic simplification removes duplicated registers.}
    \label{fig:duplicate}
  \end{figure}

\end{example}

\subsubsection{Under-Approximation} \label{subsec:under-approx}
The purpose of under-approximation is to accelerate the solving process of satisfiable instances. With the observation that the accepted string words in practical instances are usual short, we under-approximate the \emptinessprob{} by adding length bounds on string variables. The LIA formula representing possible register value is incrementally generated based on the incremental length bounds. This section discusses the implementation details of it. The main idea is to create a LIA formula enumerating all possible values of registers in accepting run within some length bounds. More detailed, The enumeration is carried out from low to high length bounds, in which the end states and registers' values of last enumeration are maintained and used in the next enumeration. Although the number of possible runs is an exponential growth of the bound, we usually solve practical satisfiable instances within 1s because the lengths of strings in the solution is generally less than 5.

As shown in the Algorithm \ref{alg:underApprox}, $\varphi_{under}$ is the under-approximated LIA formula which is initialized to the input LIA formula $\psi$ at line 2. $\varphi_\aut$ is the under-approximated LIA formula of each automaton $\aut$ which is initialized to $false$ at line 3. $lastStates$ maps each automaton $\aut$ to the set consisting of pairs of state and corresponding registers' value in the last enumeration. $lastStates(\aut)$ is initialized to the pair of initial state and zero values for each automaton $\aut$ at line 4. $length$ is the current bound of lengths of string variables which is initialized to $0$ at line 5. The main loop at line 6-20 iteratively tries possible solution from low to high length bound. For each iteration, we generate LIA formula respectively for each automaton. To each CEFA $\aut$, we get pairs of last state and corresponding registers' values from $lastStates$ at line 8. In each pair, if the last state is accepted at line 9, we add LIA formula of the possible registers' values to $\varphi_\aut$ as a conjunct at line 10.  After that, we update the set of pairs of in $lastStates$ by removing the probed pair at line 12 and adding new pairs of next state and corresponding registers' values at line 13. Finally, we combine the incremental LIA formula of each automaton at line 15. If the LIA formula $\varphi\wedge \theta$ is satisfiable at line 17, i.e., we find a solution with all strings having length less than or equal to $length$, we return \emph{true} at line 18. Otherwise, the next iteration would be invoked with a larger length. If we can not find a solution within the max string length bound, we return \emph{false} at line 22.
\begin{algorithm}[h]
  \caption{$\algfun{underApproxSolve}(auts, bound, \psi)$}
  \label{alg:underApprox}
  \begin{algorithmic}[1]
    \Require $auts$: the CEFAs, $bound$: the max string length bound, $\psi$: the LIA formula constraining the CEFAs
    % \Ensure The linear integer arithmetic $\varphi_{under}$ representing under-approximation of the register values of $auts$
    \Ensure \emph{true} if finding a solution, \emph{false} otherwise
    \Statex
    \State $\theta$ is the conjunction of all accepting conditions of $auts$
    \State $\varphi_{under}$ is an incremental LIA formula as under approximation, initialized to $\psi$
    \State $\varphi_\aut$ is an incremental LIA formula for each automaton $\aut$, initialized to $false$
    \State $lastStates(\aut)$ is the set of (last state, vector's sum) pairs of $\aut$, initialized to $\{(q_I, 0_n)\}$ 
    \State $length$ is the current bound for string-length, initialized to $0$
    \While {$length \leq bound$}
      \For{$\aut \in auts$}
        \For{$(q, \myvec{V}) \gets lastStates(\aut)$}
          \If{$q\in F$}
            \State $\varphi_{\aut} \gets \varphi_{\aut}\vee \bigwedge\limits_{i\in[1,m]} r_i = \myvec{V}[i]$
          \EndIf
          \State Remove $(q, \myvec{V})$ from $lastStates(\aut)$
          \State Add $(q', \myvec{V}+\myvec{v})$ to $lastStates(\aut)$ for each transition $q\xrightarrow[\myvec{v}]{a} q'\in \aut$
        \EndFor
        \State $\varphi_{under}\gets \varphi_{under}\wedge\varphi_\aut$
      \EndFor
      \If{$\varphi_{under}\wedge \theta$ is satisfiable}
        \State \textbf{return} \emph{true}
      \EndIf
      \State $length \gets length + 1$
    \EndWhile
    \State \textbf{return} \emph{false}
    % \For{$\aut \in auts$}
    % \State $\varphi_\aut\gets false$ 
    % \State Suppose $\aut = (Q, \Sigma, \delta, q_I, F, (r_1, \cdots, r_m), \theta)$
    % \ForAll{run $q_0q_1\cdots q_{n}$ whose length is less than $bound$}
    % \If{$q_{n}\in F$}
    % \State Let $\myvec{V}$ to be the sum of the vectors on the run
    % \State $\varphi_{\aut} \gets \varphi_{\aut} \vee(\theta(q_n)\bigwedge\limits_{i\in[1,m]} r_i = \myvec{V}[i])$
    % \EndIf
    % \EndFor
    % \State $\varphi_{under} \gets \varphi_{under}\wedge \varphi_{\aut}$
    % \EndFor
    % \State \textbf{return} $\varphi_{under}$
  \end{algorithmic}
\end{algorithm}
\begin{example}
  Consider the automaton $\aut$ in Fig. \ref{fig:overview:product:reduced} again without the LIA constraint $r_0 > 120$, i.e., $\theta$ changes to $1\leq r_1\leq 60\wedge 1\leq r_2 \leq 60\wedge 0\leq r_3 \leq 60 $. The solution of the Parikh image of it leads to a complete but inefficient result since the quantifier-free LIA formulas are solved in exponential time. Under-approximation can accelerate the solving process. In the first iteration of under-approximation, the pairs in the $lastStates(\aut)$ is the initial pair $(q_0', (0,0,0,0))$ and $\varphi_\aut$ maintains false at line 9 because $q_0'$ is not accepted. Then we update $lastStates(\aut)$ by removing the pair $(q_0', (0,0,0,0))$ and adding pairs $(q_0', (1,1,0,0)), (q_1', (1,0,1,0)), (q_2', (1,0,0,0))$. In the second iteration, $\varphi_\aut$ changes to $r_0=1\vee r_1=0\vee r_2=0\vee r_3 = 0$ because $q_2'$ is accepted. $\varphi_{under}$ is always equal to $\varphi_\aut$ since there is only one automaton. We solve the formula $\theta\wedge \varphi_{under}$ and find it is unsatisfiable. In the third iteration, the pairs in the $lastStates(\aut)$ with accepting state should be $(q_0', (2,2, 0, 0)), (q_1', (2,1,1,0))$, $(q_1', (2,0,2,0))$, $(q_2', (2,1,0,0)), (q_2', (2,0,1,0)),$ $(q_2', (2,0, 0, 0))$. The corresponding registers' values for the accepted state $q_2'$ is $(2,1,0,0), (2, 0, 1, 0), (2, 0, 0, 0)$, in which the value of $r_1$ and $r_2$ can not be both larger than 1 which is required by $\theta$. So the formula $\theta\wedge \varphi_{under}$ is still unsatisfiable. Finally, We obtain a pair $(q_2', (3,1,1,0))$ from the pair $(q_1', (2,1,1,0))$ and the transition $q_1'\xrightarrow[(1,0,0,0)]{} q_2'$, whose corresponding registers' values is a solution $(3,1,1,0)$, i.e., $r_0=3, r_1=1, r_2=1, r_3=0$.
\end{example}


\subsection{High-level algorithm}

The pseudocode presented in Algorithm \ref{alg:high} outlines the framework of our solving process. We construct the automata of all length operations occurring in the ESL conjunction $\varphi$ at line 3 and the automata of all regular memberships at line 4. In the following steps, we call an automaton to be \emph{final} if we will not operate it anymore. The set $finalAuts$ contains all final automata for all string variables and is initially empty at line 1. The intersection of $\aut_{len}$ and $\aut_{regex}$ at line 5 ensures the final automaton of $x$ reserves both length and regular information. At line 6, we compute an NFA form to throw unsat rapidly. An NFA form of CEFA is obtained by removing update functions and accepting conditions while maintaining graph structure. More exactly, given a CEFA $\aut = (Q,\Sigma, \delta, q_I, F, R, \theta)$, the NFA form of $\aut$ is $(Q, \Sigma, \delta', q_I, F)$ where $\delta'$ is composed of transition $q\xrightarrow[]{a} q'$ for $q\xrightarrow[\myvec{v}]{a} q'\in \delta$. It is obvious that the NFA form is an over-approximation of the CEFA, so that unsat is directly thrown if we find the NFA form is already empty at line 7. Sometimes the over-approximation is useful. For example, to solve the string constraint $x\in \Sigma_{/a}\{1,300\}\wedge x\in \Sigma^*a\Sigma^* $ which CVC5 has failed on, the NFA form is empty because there is no path to accepting states. 

After obtaining all final CEFAs of all string variables and their NFA forms are not empty, we check whether the final CEFAs are empty under the linear integer arithmetic $\psi$ at line 12. If they are empty under $\psi$, we return $unsat$. Otherwise, we return $sat$.

\begin{algorithm}[h]
  \caption{High-level algorithm}
  \label{alg:high}
  \begin{algorithmic}[1]
    \Require Conjunction of literals $\varphi$ and conjunction of linear literals $\psi$
    \Ensure \emph{sat} or \emph{unsat}
    \Statex
    \State $finalAuts \leftarrow \emptyset$
    \ForAll{string variables $x$ occurring in $\varphi$}
    \State $\aut_{len} \leftarrow$ intersection of all pre-images of $i=|x|$ in $\varphi$
    \State $\aut_{regex} \leftarrow$ intersection of all CEFAs of $x \in \regex$ in $\varphi$
    \State $\aut_x \leftarrow$ intersection of $\aut_{len}$ and $\aut_{regex}$
    \State $\aut_{nfa} \leftarrow$ NFA form of $\aut_x$
    \If{$\aut_{nfa}$ is empty}
    \State \textbf{return} \emph{unsat}
    \EndIf
    \State $finalAuts \leftarrow finalAuts \cup \{\aut_x\}$
    \EndFor
    \If{$\algfun{isEmpty}(finalAuts, \psi)$ }
    \State \textbf{return} \emph{unsat}
    \Else
    \State \textbf{return} \emph{sat}
    \EndIf
  \end{algorithmic}
\end{algorithm}



%\end{document}