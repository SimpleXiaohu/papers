% \subsection{Concatenation}\label{subsec:con}
% Given two CEFAs $\aut_1 = (Q_1, \Sigma, \delta_1, q_{I_1}, F_1, R_1, \theta_1)$ and $\aut_2 = (Q_2, \Sigma, \delta_2, q_{I_2}, F_2, R_2, \theta_2)$ with $R_1\cap R_2= \emptyset$ and $|R_1|=m,|R_2|=n$, the concatenation of them is defined as $\aut_{\cdot}=(Q_1\cup Q_2, \Sigma, \delta', q_{I_1}, F_2, R_1\cdot R_2, \theta_1\wedge\theta_2)$ where $\delta'$ is composed by
% \begin{itemize}
%   \item $q_1\xrightarrow[\myvec{v_1}\cdot 0_n]{a} q_1'$ for each transition $q_1\xrightarrow[\myvec{v_1}]{a} q_1' \in \delta_1$,
%   \item $q_2\xrightarrow[0_m\cdot\myvec{v_2}]{a} q_2'$ for each transition $q_2\xrightarrow[\myvec{v_2}]{a} q_2' \in \delta_2$,
%   \item and $q_1\xrightarrow[0_{m+n}]{\epsilon} q_{I_2}$ for each $q_1\in F_1$.
% \end{itemize}
% % \begin{figure}[h]
% %   \centering
% %   \begin{subfigure}{0.20\textwidth}
% %     \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,>={Stealth[round]},
% %       every fit/.style={draw,minimum height=2cm,minimum width=3.5cm,dashed},
% %       every state/.style={draw=blue!50,minimum size = 0.1cm}, initial text=]
% %       \node[state, initial]   (q_0) {};
% %       \node[state, accepting]    (q_1) [right=of q_0] {};
% %       \path[->] (q_0) edge [bend right] node [below] {$a/\myvec{v_1}$} (q_1);
% %       \node [fit=(q_0) (q_1)] {$\cdots$};
% %     \end{tikzpicture}
% %     \caption{The CEFA $\aut_1$}
% %   \end{subfigure}
% %   \begin{subfigure}{0.20\textwidth}
% %     \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,>={Stealth[round]},
% %       every fit/.style={draw,minimum height=2cm,minimum width=3.5cm,dashed},
% %       every state/.style={draw=blue!50,minimum size = 0.1cm}, initial text=]
% %       \node[state, initial]   (q_0) {};
% %       \node[state, accepting]    (q_1) [right=of q_0] {};
% %       \path[->] (q_0) edge [bend right] node [below] {$a/\myvec{v_2}$} (q_1);
% %       \node [fit=(q_0) (q_1)] {$\cdots$};
% %     \end{tikzpicture}
% %     \caption{The CEFA $\aut_2$}
% %   \end{subfigure}
% %   \begin{subfigure}{0.4\textwidth}
% %     \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,>={Stealth[round]},
% %       every fit/.style={draw,minimum height=2cm,minimum width=3.5cm,dashed},
% %       every state/.style={draw=blue!50,minimum size = 0.1cm}, initial text=]
% %       \node[state, initial]   (q_0) {};
% %       \node[state]    (q_1) [right=of q_0] {};
% %       \node[state]    (q_2) [right=of q_1] {};
% %       \node[state, accepting]    (q_3) [right=of q_2] {};
% %       \path[->]
% %       (q_0) edge [bend right] node [below] {$a/\myvec{v_1}\cdot \red{0_n}$} (q_1)
% %       (q_1) edge node [below] {$\red{0_{m+n}}$} (q_2)
% %       (q_2) edge [bend right] node [below] {$a/\red{0_m}\cdot \myvec{v_2}$} (q_3);
% %       \node [fit=(q_0) (q_1)] {$\cdots$};
% %       \node [fit=(q_2) (q_3)] {$\cdots$};
% %     \end{tikzpicture}
% %     \caption{The concatenation of $\aut_1$ and $\aut_2$}
% %   \end{subfigure}
% %   \caption{Concatenation}
% %   \label{fig:con}
% % \end{figure}
% % The concatenation of two CEFAs is similar to that of two NFAs, except that the registers and their updates are also concatenated.

% % Figure \ref{fig:con} outlines the vector change on transitions when concatenating two CEFA. Without losing information, $\aut_{\cdot}$ contains all registers in $\aut_1$ and $\aut_2$. Furthermore, $\aut_{\cdot}$ update registers' value of $\aut_1$ and $\aut_2$ separately: $\aut_{\cdot}$ only update registers of $R_1$ on the transitions of $\aut_1$ and update registers of $R_2$ on the transition of $\aut_2$. $\theta'$ is the conjunction of $\theta_1$ and $\theta_2$ to make sure all linear constraints in $\aut_1$ and $\aut_2$ are satisfiable.
% \subsection{Intersection}\label{subsec:inter}
% Given two CEFAs $\aut_1 = (Q_1, \Sigma, \delta_1, q_{I_1}, F_1, R_1, \theta_1)$ and $\aut_2 = (Q_2, \Sigma, \delta_2, q_{I_2}, F_2, R_2, \theta_2)$ with $R_1\cap R_2 = \emptyset$, the intersection of them is defined as $\aut_{\times} = (Q_1\times Q_2, \Sigma, \delta', q_{I_1}\times q_{I_2}, F_1\times F_2, R_1\cdot R_2, \theta_1\wedge \theta_2)$ where $\delta'$ is composed by
% \begin{itemize}
%   \item transitions $(q_1,q_2)\xrightarrow[\myvec{v_1}\cdot\myvec{v_2}]{a} (q_1',q_2')$ if transition $q_1\xrightarrow[\myvec{v_1}]{a}q_1'$ and transition $q_2\xrightarrow[\myvec{v_2}]{a}q_2'$ exist individually in  $\delta_1$ and $\delta_2$.
% \end{itemize}
% % \begin{figure}[h]
% %   \centering
% %   \begin{subfigure}{0.20\textwidth}
% %     \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,>={Stealth[round]},
% %       every fit/.style={draw,minimum height=2cm,minimum width=3.5cm,dashed},
% %       every state/.style={draw=blue!50,minimum size = 0.1cm}, initial text=]
% %       \node[state, initial]   (q_0) {};
% %       \node[state, accepting]    (q_1) [right=of q_0] {};
% %       \path[->]
% %       (q_0) edge [bend right] node [below] {$a$/$\myvec{v_1}$} (q_1)
% %       (q_0) edge [bend left] node [above] {$b$/$\myvec{v_1}$} (q_1);
% %       \node [fit=(q_0) (q_1)] {$\cdots$};
% %     \end{tikzpicture}
% %     \caption{The CEFA $\aut_1$}
% %   \end{subfigure}
% %   \begin{subfigure}{0.20\textwidth}
% %     \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,>={Stealth[round]},
% %       every fit/.style={draw,minimum height=2cm,minimum width=3.5cm,dashed},
% %       every state/.style={draw=blue!50,minimum size = 0.1cm}, initial text=]
% %       \node[state, initial]   (q_0) {};
% %       \node[state, accepting]    (q_1) [right=of q_0] {};
% %       \path[->]
% %       (q_0) edge [bend right] node [below] {$a$/$\myvec{v_2}$} (q_1)
% %       (q_0) edge [bend left] node [above] {$c$/$\myvec{v_2}$} (q_1);
% %       \node [fit=(q_0) (q_1)] {$\cdots$};
% %     \end{tikzpicture}
% %     \caption{The CEFA $\aut_2$}
% %   \end{subfigure}
% %   \begin{subfigure}{0.4\textwidth}
% %     \centering
% %     \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,>={Stealth[round]},
% %       every fit/.style={draw,minimum height=2cm,minimum width=3.5cm,dashed},
% %       every state/.style={draw=blue!50,minimum size = 0.1cm}, initial text=]
% %       \node[state, initial]   (q_0) {};
% %       \node[state, accepting]    (q_3) [right=of q_0] {};
% %       \path[->]
% %       (q_0) edge [bend right] node [below] {$a$/\red{$\myvec{v_1}\cdot \myvec{v_2}$}} (q_3);
% %       \node [fit=(q_0) (q_3)] {$\cdots$};
% %     \end{tikzpicture}
% %     \caption{The intersection of $\aut_1$ and $\aut_2$}
% %   \end{subfigure}
% %   \caption{Intersection}
% %   \label{fig:inter}
% % \end{figure}
% % The intersection of two CEFAs is similar to that of NFA, except that the vectors and linear arithmetic are also intersected.

% \subsection{Union}\label{subsec:union}
% Given two CEFAs $\aut_1 = (Q_1, \Sigma, \delta_1, q_{I_1}, F_1, R_1, \theta_1)$ and $\aut_2 = (Q_2, \Sigma, \delta_2, q_{I_2}, F_2, R_2, \theta_2)$ with $R_1\cap R_2 = \emptyset$ and $|R_1|=m,|R_2|=n$, the union of them is defined as $\aut_{+} = (Q_1\cup Q_2\cup\{q_0\}, \Sigma, \delta', \{q_I\}, F_1\cup F_2, R_1\cdot R_2\cdot (r_1, r_2), \theta')$ where $\delta'$ is composed by
% \begin{itemize}
%   \item transitions $q_I\xrightarrow[0_{m+n}\cdot(1,0)]{\epsilon}q_1$ for all $q_1\in I_1$,
%   \item transitions $q_I\xrightarrow[0_{m+n}\cdot(0,1)]{\epsilon}q_2$ for all $q_2\in I_2$,
%   \item transitions $q_1\xrightarrow[\myvec{v_1}0_{n+2}]{a} q_1'$ for all $q_1\xrightarrow[\myvec{v_1}]{a} q_1'\in \delta_1$,
%   \item transitions $q_2\xrightarrow[0_m\myvec{v_2}0_2]{a} q_2'$ for all $q_2\xrightarrow[\myvec{v_2}]{a} q_2'\in \delta_2$.
% \end{itemize}
% $r_1$ and $r_2$ are new registers to determine which automaton to run. $q_I$ is a new state where $q_I\not\in Q_1$ and $q_I\not\in Q_2$. Assume that basic determining formula $\theta$  is $(r_1>0\wedge\theta_1)\vee(r_2>0\wedge\theta_2)$, $\theta'$ is constructed differently in four cases:
% \begin{itemize}
%   \item $q_{I_1}\in F\wedge q_{I_2}\in F$: $\theta'$ = $\theta $;
%   \item $q_{I_1}\in F\wedge q_{I_2}\not\in F$: $\theta'$ = $\theta \vee (r_1==0\wedge r_2==0\wedge\theta_1)$;
%   \item $q_{I_1}\not\in F\wedge q_{I_2}\in F$: $\theta'$ = $\theta \vee (r_1==0\wedge r_2==0\wedge\theta_2)$;
%   \item $q_{I_1}\in F\wedge q_{I_2}\in F$: $\theta'$ = $\theta \vee (r_1==0\wedge r_2==0\wedge(\theta_1\vee\theta_2))$;
% \end{itemize}

% % \begin{figure}[h]
% %   \centering
% %   \begin{subfigure}{0.20\textwidth}
% %     \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,>={Stealth[round]},
% %       every fit/.style={draw,minimum height=2cm,minimum width=3.5cm,dashed},
% %       every state/.style={draw=blue!50,minimum size = 0.1cm}, initial text=]
% %       \node[state, initial]   (q_0) {};
% %       \node[state, accepting]    (q_1) [right=of q_0] {};
% %       \path[->]
% %       (q_0) edge [bend left] node [above] {$a$/$\myvec{v_1}$} (q_1);
% %       \node [fit=(q_0) (q_1)] {$\cdots$};
% %     \end{tikzpicture}
% %     \caption{The CEFA $\aut_1$}
% %   \end{subfigure}
% %   \begin{subfigure}{0.20\textwidth}
% %     \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,>={Stealth[round]},
% %       every fit/.style={draw,minimum height=2cm,minimum width=3.5cm,dashed},
% %       every state/.style={draw=blue!50,minimum size = 0.1cm}, initial text=]
% %       \node[state, initial]   (q_0) {};
% %       \node[state, accepting]    (q_1) [right=of q_0] {};
% %       \path[->]
% %       (q_0) edge [bend right] node [below] {$a$/$\myvec{v_2}$} (q_1);
% %       \node [fit=(q_0) (q_1)] {$\cdots$};
% %     \end{tikzpicture}
% %     \caption{The CEFA $\aut_2$}
% %   \end{subfigure}
% %   \begin{subfigure}{0.4\textwidth}
% %     \centering
% %     \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,>={Stealth[round]},
% %       every fit/.style={draw,minimum height=2cm,minimum width=3.5cm,dashed},
% %       every state/.style={draw=blue!50,minimum size = 0.1cm}, initial text=]
% %       \node[state, initial]   (q_0) {};
% %       \node[state]   (q_1) [above right=of q_0] {};
% %       \node[state, accepting]   (q_1') [right=of q_1] {};
% %       \node[state]   (q_2) [below right=of q_0] {};
% %       \node[state, accepting]   (q_2') [right=of q_2] {};
% %       \path[->]
% %       (q_0) edge node [left] {$\epsilon/\red{0_{m+n}\cdot(1,0)}$} (q_1)
% %       (q_0) edge node [left] {$\epsilon/\red{0_{m+n}\cdot(0,1)}$} (q_2)
% %       (q_1) edge [bend left] node [above] {$a$/\red{$\myvec{v_1}\cdot 0_{n+2}$}} (q_1')
% %       (q_2) edge [bend right] node [below] {$a$/\red{$0_m\cdot \myvec{v_2}\cdot 0_2$}} (q_2');
% %       \node [fit=(q_1) (q_1')] {$\cdots$};
% %       \node [fit=(q_2) (q_2')] {$\cdots$};
% %     \end{tikzpicture}
% %     \caption{The union of $\aut_1$ and $\aut_2$}
% %   \end{subfigure}
% %   \caption{Union}
% %   \label{fig:union}

% % \end{figure}
% To simulate the semantics of the union, we add transitions from $q_I$ to initial states of $\aut_1$ and $\aut_2$ to choose one automaton randomly. $r_1 > 0$ indicates we choose $\aut_1$ to run while $r_2 > 0$ indicates that we choose $\aut_2$ to run. The basic determining formula $(r_1>0\wedge\theta_1)\vee(r_2>0\wedge\theta_2)$ means that the accepting condition of chosen automaton should be satisfied. Furthermore, the accepting run may stop at the new initial state $q_I$ with $\mathcal{V}(r_1) = 0, \mathcal{V}(r_2)=0$ when some initial states of two given CEFAs are accepting. More precise, the accepting condition contains $r_1==0\wedge r_2==0\wedge\theta_1$ if $q_{I_1}$ is accepting and contains $r_1==0\wedge r_2==0\wedge\theta_2$ if $q_{I_2}$ is accepting.
% \subsection{Complement} \label{subsec:complement}
% Given an CEFA $\aut = (Q, \Sigma, q_{I}, F, \delta, \emptyset, true)$, the complement is defined as the CEFA $\aut_c = (Q', \Sigma, q_{I}, F', \delta', \emptyset, true)$ where $(Q', \Sigma, q_{I}, F', \delta')$ is the complement of NFA $(Q, \Sigma, q_{I}, F, \delta)$.
% \subsection{Closure} \label{subsec:closure}
% Given an CEFA $\aut = (Q, \Sigma, q_{I}, F, \delta, \emptyset, true)$, the complement is defined as the CEFA $\aut_c = (Q', \Sigma, q_{I}, F', \delta', \emptyset, true)$ where $(Q', \Sigma, q_{I}', F', \delta')$ is the closure of NFA $(Q, \Sigma, q_{I}', F, \delta)$.
% \subsection{Inductive Steps} \label{subsec:regex2cefa}
% \highlight{Basis}: The basis has three parts with empty registers and valid accepting conditions, shown in Fig. \ref{fig:basis}. In part \ref{fig:basis:a}, we see how to handle the expression $\epsilon$. The language of the automaton is easily seen to be $\{\epsilon\}$ since the only path from the start state to an accepting state
% is labeled $\epsilon$. Part \ref{fig:basis:b} gives the CEFA for a regular expression $a$. The language of this CEFA consists of the single string $a$, which is also $\lan(a)$. Finally, part \ref{fig:basis:c} shows the construction for empty language $\emptyset$. There are no paths from the initial state to the accepting state.
% \begin{figure}[h]
%   \centering
%   \begin{subfigure}{0.3\textwidth}
%     \centering
%     \begin{tikzpicture}[shorten >=1pt,node distance=1.2cm,on grid,>={Stealth[round]},
%       every fit/.style={draw,minimum height=1.0cm,minimum width=2.2cm,dashed},
%       every state/.style={minimum size = 0.001cm}, initial text=]
%       \node[state, initial]   (q_0) {};
%       \node[state, accepting]    (q_1) [right=of q_0] {};
%       \path[->] (q_0) edge node [below] {$\epsilon/\emptyset$} (q_1);
%       \node [fit=(q_0) (q_1)] {};
%     \end{tikzpicture}
%     \caption{}
%     \label{fig:basis:a}
%   \end{subfigure}
%   \begin{subfigure}{0.3\textwidth}
%     \centering
%     \begin{tikzpicture}[shorten >=1pt,node distance=1.2cm,on grid,>={Stealth[round]},
%       every fit/.style={draw,minimum height=1.0cm,minimum width=2.2cm,dashed},
%       every state/.style={minimum size = 0.1cm}, initial text=]
%       \node[state, initial]   (q_0) {};
%       \node[state, accepting]    (q_1) [right=of q_0] {};
%       \path[->] (q_0) edge node [below] {$a/\emptyset$} (q_1);
%       \node [fit=(q_0) (q_1)] {};
%     \end{tikzpicture}
%     \caption{}
%     \label{fig:basis:b}
%   \end{subfigure}
%   \begin{subfigure}{0.3\textwidth}
%     \centering
%     \begin{tikzpicture}[shorten >=1pt,node distance=1.2cm,on grid,>={Stealth[round]},
%       every fit/.style={draw,minimum height=1.0cm,minimum width=2.2cm,dashed},
%       every state/.style={minimum size = 0.1cm}, initial text=]
%       \node[state, initial]   (q_0) {};
%       \node[state, accepting]    (q_1) [right=of q_0] {};
%       \node [fit=(q_0) (q_1)] {};
%     \end{tikzpicture}
%     \caption{}
%     \label{fig:basis:c}
%   \end{subfigure}
%   \caption{The basis of the construction of an CEFA from extended regex}
%   \label{fig:basis}
% \end{figure}\\
% \highlight{Induction}: Given a regular expression $\regex'$, we can construct an automaton $\aut$ such that $\lan(\aut)=\lan(\regex')$ by the cases below:
% \begin{enumerate}
%   \item The expression is $\regex\{m,n\}$ for some smaller expression $\regex$. $\aut$ is constituted as the repetition on $\aut_\regex$ with lower bound $m$ and upper bound $n$ as shown in section \ref{subsec:rep}.
%   \item The expression is $\regex_1\cdot\regex_2$ for some smaller expression $\regex_1$ and $\regex_2$. $\aut$can concatenate the CEFA of $\regex_1$ and the CEFA of $\regex_2$ as shown in section \ref{subsec:con}.
%   \item The expression is $\regex_1\times \regex_2$ for some smaller expression $\regex_1$ and $\regex_2$. $\aut$ is constituted as the intersection of $\aut_{\regex_1}$ and $\aut_{\regex_2}$ as shown in section \ref{subsec:inter}.
%   \item The expression is $\regex_1 + \regex_2$ for some smaller expression $\regex_1$ and $\regex_2$. $\aut$ is constituted as the union of $\aut_{\regex_1}$ and $\aut_{\regex_2}$ as shown in section \ref{subsec:union}.
%   \item The expression is $\regex*$ for some smaller expression $\regex$. $\aut$ is constituted as the closure of $\aut_\regex$  as shown in section \ref{subsec:closure}.
%   \item The expression is $\regex^C$ for some smaller expression $\regex$. $\aut$ is constituted as the complement of $\aut_\regex$  as shown in section \ref{subsec:complement}.
% \end{enumerate}
% % \highlight{Special Case}: When the expression $\regex$ contains nested repetition, we firstly write $\regex$ to a new regex $\regex'$ without nested repetition. Then we build the CEFA of the new expression $\regex'$ by basis and induction steps.

% \subsection{Parikh Image} \label{subsec:parikh}

% Suppose the input ESL cube is $\varphi$. For each string variable $x$ in the formula, firstly, we construct the CEFA for each regular membership $x\in\regex$ or $x\not\in \regex$. Secondly, we compute the pre-images of length operations such as $i = |x|$ \ref{pre-example}. Thirdly, we intersect constructed CEFAs and pre-images to obtain a large CEFA $\aut_x$. The accepting words of $\aut_x$ belong to the intersection of all regexes and have a strict length concerning length operations. The transitions and states of $\aut_x$ are usually abundant, so $\aut_x$ have to be simplified. After the simplification, we compute an equivalent quantifier-free Presburger formula $\psi(\aut_x)$ to intersect other linear literals in $\varphi$ to refine the length of $x$. That is, the final Presburger formula $\bigwedge\limits_{x\in strvar(\varphi)} \psi(\aut)\wedge \varphi_{LIA}$ where $\varphi_{LIA}$ is the conjunction of all linear literals in $\varphi$. We use the off-the-shelf SMT solver (we use the SMT solver Princess\cite{princess}) to solve it. Note that the satisfiability of $\varphi$ equals the satisfiability of the final Presburger formula. \newlineo

% Finally, we obtain the Parikh images $\psi(\aut_x)$ and $\psi(\aut_y)$ based on the construction in subsection \ref{subsec:parikh} and solve the final Presburger formula $\psi(\aut_x)\wedge \psi(\aut_y)\wedge \varphi_{LIA}$. As mentioned above, $\psi(\aut_x) \equiv t_3\geq 0 \wedge t_1=1\wedge r_1 = t_3 + 1\wedge r_2 = 2*t_3+2\wedge r_2=i\wedge 1\leq r_1\leq 100$. Similarly, the Parikh image $\psi(\aut_y)$ is $t_4=1\wedge t_4 = t_5 \wedge t_5 = 1\bigwedge \top \bigwedge r3=t_4+t_5 \bigwedge r_3=j$ and is simplified to $r_3 = j\wedge r_3 = 2$. Then, the final Presburger formula is $t_3\geq 0 \wedge r_1 = t_3 + 1\wedge r_2 = 2*t_3+1\wedge r_2=i\wedge 1\leq r_1\leq 100\wedge r_3=2 \wedge i>j$. One solution for it is $t_3=1, r_1=2, r_2=3, r_3=2, i=3, j=2$ and the corresponding assignment is $x=abab, y=ab$.


% first-order logic 
% \subsubsection{CNF, DNF, and Cube}
% We assume that the reader is familiar with the first-order logic. A \emph{literal} is an atomic proposition or its negation. A \emph{clause} is a disjunction of literals. The empty clause is $true$. A formula is in \emph{conjunctive normal norm} (CNF) if it is a conjunction of clauses. A \emph{cube} is a conjunction of a consistent set of literals; The empty cube is $false$. A formula is in \emph{disjunctive normal form} (DNF) if it is a disjunction of cubes.
% Syntax of our quantifier-free string formulas

% This paper proposes a quantifier-free first-order logic called \textit{Extended String Logic (ESL)}. ESL contains the following
% sorts: string sort \verb|Str|, integer sort \verb|Int|, the enumerable set of string
% sort $\verb|Str|^m$, and the enumerable set of integer sort $\verb|Int|^m$ for each $m\in
%   \mathbb{Z}$. Furthermore, ESL includes the following predicate and function constants:
% string concatenation $\verb|con|:\verb|Str|\times\verb|Str|\rightarrow \verb|Str|$;
% string length $|\cdot|: \verb|Str|\rightarrow \verb|Int|$; regular membership
% $\in:
%   \verb|Str|\times \verb|Str|^m$; the regex operators include closure, concatenation,  conjunction, disjunction, intersection, repetition, and complement, and the usual constants of linear arithmetic.

% Normal form 
% \subsubsection{Normal Form}
% ESL formula $\varphi$ can be transformed to disjunctive normal from $\varphi_d$. $\varphi_d$ is satisfiable if and only if there is a satisfiable cube $c$ in $\varphi_d$. Without loss of generality, our paper focus on the satisfiability problem of the cube. Each cube can be transferred to a \emph{normal formal} where the term $|x|$ only occurs in literal $i=|x|$. The transformation is done in two steps: (i) substitute each integer term $|x|$ with a new integer variable $i_x$. (ii) append $i_x = |x|$ to the new formula. More precisely, suppose that $\varphi_s$ is the formula obtained from $\varphi$ by substitute each term $|x|$ with a fresh integer variable $i_x$, then $\varphi' = \varphi_{s}\wedge\bigwedge\limits_{|x|\in term(\varphi)} i_x = |x|$.
% \subsubsection{Problem}
% In this paper, we consider the following problem:
% \begin{table}[h]
%   \centering
%   \begin{tabular}{l l}
%     \hline
%     \textbf{Problem:} & Is an $ESL$ cube $\varphi$ in normal form satisfiable? \\
%     \textbf{Input:}   & The cube $\varphi$ in normal form.                                    \\
%     \textbf{Output:}  & \emph{sat} or \emph{unsat}.                            \\
%     \hline
%   \end{tabular}
% \end{table}
% \highlight{Basic Regular Language.} A nondeterministic finite state automaton (NFA) is a tuple $\aut=(Q, \Sigma, \delta, I, F)$ where $Q$ is a finite set of states; $\Sigma$ is a finite alphabet; $\delta\in Q\times\Sigma\times Q$ is the transition relation; $I, F\subseteq Q$ are the set of initial states and finite states respectively. We write a transition $(q, a, q') \in \delta$ as $q\xrightarrow{a} q'$ for readability. A \emph{run} of an NFA $\aut$ on a string $w = a_1\cdots a_n$ is a sequence of transitions $q_0\xrightarrow{a_1}q_1\cdots q_{n-1}\xrightarrow{a_n}q_n$ with $q_0\in I$. The run is \emph{accepting} if $q_{n}\in F$. A word $w$ is \emph{accepted} by an NFA $\aut$ if there is an accepting run on $w$. The \emph{language} of $\aut$ is the set of all words accepted by $\aut$, denoted by $\lan(\aut)$. From automata theory\cite{aut_hopcraft}, basic regular expression only contains union, concatenation, and closure operations. We know that the language of the basic regular expression is also in the class of $\lan(\aut)$ and is called \emph{Basic Regular Language}.

% However, if we naively rewrite the repetition operation, the state's size of the corresponding nondeterministic finite automaton is linear to the repetition times. The search space is exponential. To address the issue, we proposed a new automaton model called \emph{Cost-Enriched Finite Automaton (CEFA)}, whose size is irrelevant to the repetition times. CEFA can not handle nested repetition (e.g., $\regex\{m_1,n_1\} \regex\{m_2,n_2\}$ or $(\regex\{m, n\}) *$) and complement of repetition (e.g, $(\regex\{m,n\})^C$). So we have to rewrite these regexes syntactically (e.g., $a\{1,100\}\{2,2\}$ is rewritten to $a\{1,100\}a\{1,100\}$).\newline


% \subsection{Over-Approximation}
% Sometimes, when the bound reaches the maximum, the linear integer arithmetic $\varphi_{under}$ is still unsatisfiable. We must use over-approximation to solve the emptiness checking problem in this case. The main idea of over-approximation is to split each CEFA into sub-CEFAs, translate each sub-CEFA respectively, and finally in conjunction with the LIA of all sub-CEFAs. The details are shown in the Algorithm \ref{alg:overApprox}. Firstly, each CEFA is split into $n$ sub-CEFAs, where $n$ is the number of registers in the CEFA. The sub-CEFA has only one register. After simplifying each sub-CEFA by Algorithm \ref{alg:simplify}, the vector of each transition must be $\myvec{1}$. So the register value of each sub-CEFA equals the length of the accepted path. We apply the efficient construction of semilinear representations\cite{unary_nfa_2010} to get the linear integer arithmetic $\varphi_{over}$.
% \begin{algorithm}
%   \caption{$\algfun{overApprox}(auts)$}
%   \label{alg:overApprox}
%   \begin{algorithmic}[1]
%     \Require CEFAs $auts$
%     \Ensure Linear integer arithmetic $\varphi_{over}$
%     \Statex
%     \State $\varphi_{over} \gets true$
%     \For{$aut \in auts$}
%     \State Let $subAut$ be the sub-CEFA of $aut$ with only one register
%     \State Let $subAut \gets \algfun{simplify}(subAut)$
%     \State Let $\varphi_{subAut}$ be the linear integer arithmetic generated by efficient construction of semilinear representations
%     \State $\varphi_{over} \gets \varphi_{over} \wedge \varphi_{subAut}$
%     \EndFor
%     \State \textbf{return} $\varphi_{over}$
%   \end{algorithmic}
% \end{algorithm}

